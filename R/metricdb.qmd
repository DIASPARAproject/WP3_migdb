---
title: "DIASPARA WP3.4 FISH STOCK DATABASE"
subtitle: "METRIC DB final report"
author: "Briand Cédric, Oliviero Jules, Helminen Jani"
date: last-modified
date-format: "DD-MM-YYYY"
description: "version = pre-release, for review. Still have to integrate salmon from WP2"
title-block-banner: "images/diaspara_bandeau.png"
title-block-banner-color: "white"
format:
 html:
  self-contained: true
  theme: styles.scss
  smooth-scroll: true
  fontcolor: black
  toc: true
  toc-location: left
  toc-title: Contents
  toc-depth: 3
execute: 
 keep-md: true
filters:
  - include-code-files
reference-location: document
bibliography: diaspara.bib
include-after-body: "footer.html"
---



```{r init}
#| echo: FALSE
#| warning: FALSE
#| message: FALSE
#| results: 'hide'

#if (!grepl("montepomi", getwd())) {
if(Sys.info()[["user"]] == 'joliviero'){
  setwd("D:/workspace/DIASPARA_WP3_migdb/R")
  datawd <- "D:/DIASPARA/wgbast"
} else if (Sys.info()[["user"]] == 'cedric.briand'){
  setwd("C:/workspace/DIASPARA_WP3_migdb/R")
  datawd <- "C:/Users/cedric.briand/OneDrive - EPTB Eaux&Vilaine/Projets/DIASPARA/wgbast"
}
source("utilities/load_library.R")
load_library("tidyverse")
load_library("knitr")
load_library("kableExtra")
load_library("icesVocab")
load_library("readxl")
load_library("janitor")
load_library("skimr")
load_library("RPostgres")
load_library("yaml")
load_library("DBI")
load_library("ggplot2")
load_library("sf")
load_library("janitor") # clean_names
load_library("uuid")
cred <- read_yaml("../credentials.yml")
con_diaspara <- dbConnect(Postgres(), 
                          dbname = cred$dbnamediaspara,
                          host = cred$hostdistant,
                          port = cred$port,
                          user = cred$userdiaspara,
                          password = cred$passworddiaspara)
con_diaspara_admin <- dbConnect(Postgres(), 
                                dbname = cred$dbnamediaspara,
                                host = cred$hostdistant,
                                port = cred$port,
                                user = cred$userdistant,
                                password = cred$passworddistant)
con_salmoglob <- dbConnect(Postgres(), 
                           dbname = cred$dbnamesalmo,
                           host = cred$hostdistant,
                           port = cred$port,
                           user = cred$usersalmo,
                           password = cred$passwordsalmo)
con_wgeel_distant <- dbConnect(Postgres(), 
                               dbname = cred$dbnamedistant,
                               host = cred$hostdistant,
                               port = cred$port,
                               user = cred$userdistant,
                               password = cred$passworddistant)
# con_wgeel_local <- dbConnect(Postgres(), 
#                            dbname = "wgeel",
#                            host = "127.0.0.1",
#                            port = cred$port,
#                            user = cred$userdistant,
#                            password = cred$passwordsalmo)


```

Aside the main db report, which describes all the vocabularies used in this document, we have to build a separate database for metrics. In the project these correspond to LHT, but additionally, the data should also correspond to the time series and the sampling db developed by WGEEL. The two latter data structure (series and sampling) are very similar and they both hold very similar group metrics and individual metrics.

The first was developed initially to store data about the series used in recruitment. In practice, it consists of three tables, the `t_series_ser` (Figure @fig-series_diagram_wgeel - top in blue) table contains series id and description, with columns describing the sampling details, the stage used, the method... This is the main identifier of the series which will be used as a reference in all dependent tables. The second `t_dataseries_das` table  (Figure @fig-series_diagram_wgeel - on the right) holds data about annual values in series. These are typically annual counts for recruitment, along with additional effort data. Linked to these are group metric series used to describe the series, mean age of eel, mean size, proportion of glass eel among the yellow eels, proportion of females ... (Figure @fig-series_diagram_wgeel - in orange)
Finally, we can link individual metrics. The individual metrics are all detailed for one fish. And they concern metrics like size, weight, sex, but also can hold data about quality, contamination. So these are in essence the Life History traits analysed by WP2 in DIASPARA  (Figure @fig-series_diagram_wgeel - in pink).

![Diagram for series](images/series_diagram_wgeel.png "A sql diagram of the relations of tables for series"){#fig-series_diagram_wgeel}

The second type of data was developed to hold the data collected for DCF. These can be metrics collected from sampling by the fishermen, data coming from the analysis of electrofishing data, or other experimental sampling that are not reported as series. Currently the two structures for series and sampling are very close, the only difference is that there is no annual number linked to the sampling data, and that they are not linked to a stage in the first table, so the stage is added in the fish table.
The difference in table structure is illustrated below in tables highlighted in yellow (Figure @fig-sampling_diagram_wgeel).

![Diagram for sampling](images/sampling_diagram_wgeel.png "A sql diagram of the relations of tables for sampling"){#fig-sampling_diagram_wgeel}

The database development highlighted in the current report has several objectives :

* The first objective is to join the two database to simplify the database development and handling of data.

* The second objective is to use the new referentials created for the migdb database.

* The third objective is to import data from WP2, the excel sheets have been created in february 2025 and will already (in March) require some adaptation as the database evolves, for instance the referential of stages is no longer in line with the templates.

* The fourth objective is to hand over this database, along with the migdb to ICES, for integration in ICES database ecosystem, and use of DATSU in datacall.

* The fifth objective is to adapt the shiny scripts of data integration.

# Building database structure from WGEEL 


[git issue #23 Write simplified structure from WGEEL](https://github.com/DIASPARAproject/WP3_migdb/issues/23)

The main issue will require to merge the two table structures (sampling and series) and adapt to migdb vocabulary.

Once done a beta version probably not completely adapted will be released.

[milestone metric DB beta version](https://github.com/DIASPARAproject/WP3_migdb/milestone/6)



## Station

To include the station, we need two tables, the fist one is the Station dictionary
and the second is the relation Dictionary (which relates two stations together).
Now these tables in turn rely on some vocabs from ICES which we are loading
straight as they are in our template database.




### SemanticRelation


```{r tbl-icesVocabRelation}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show SemanticRelation.
#| tbl-cap: Semantic relation
SemanticRelation <- getCodeList("SemanticRelation")
knitr::kable(SemanticRelation)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```
```{r icesVocabRelation}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import relation.
#| tbl-cap: Semantic relation
dbWriteTable(con_diaspara, "SemanticRelation", PRGOV)
dbExecute(con_diaspara, 'ALTER TABLE "SemanticRelation" SET SCHEMA ref;') 
dbExecute(con_diaspara,
          'ALTER TABLE ref."SemanticRelation" ADD CONSTRAINT semanticrelation_pkey PRIMARY KEY ("Key");') 

```

### PRGOV
```{r tbl-icesPRGOV}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show PRGOV.
#| tbl-cap: Program Governance for the Station Dictionary (10 first lines)


PRGOV <- getCodeList("PRGOV")
knitr::kable(PRGOV)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

```{r icesPRGOV}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import PRGOV.
#| tbl-cap: Program Governance for the Station Dictionary
dbWriteTable(con_diaspara, "PRGOV", PRGOV)
dbExecute(con_diaspara, 'ALTER TABLE "PRGOV" SET SCHEMA ref;') 
dbExecute(con_diaspara, 
          'ALTER TABLE ref."PRGOV" ADD CONSTRAINT prgov_pkey PRIMARY KEY ("Key");') 
```

### EDMO

```{r tbl-icesEDMO}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show EDMO.
#| tbl-cap: European Directory of Marine Organisations (EDMO)


EDMO <- getCodeList("EDMO")|>slice_head(n=10)  |>
  knitr::kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```


:::{.callout-tip appearance="simple"}
## Addings institutions to the EDMO
To request a new EDMO an organisation needs to send an email to info@maris.nl
:::



```{r icesEDMO}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import EDMO.
#| tbl-cap: European Directory of Marine Organisations (EDMO)

dbWriteTable(con_diaspara, "EDMO", EDMO)
dbExecute(con_diaspara, 'ALTER TABLE "EDMO" SET SCHEMA ref;')  
dbExecute(con_diaspara, 
          'ALTER TABLE ref."EDMO" ADD CONSTRAINT edmo_pkey PRIMARY KEY ("Key");')  
```

### PURPM

```{r tbl-icesPURPM}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show PURPM.
#| tbl-cap: Purpose of Monitoring


PURPM <- getCodeList("PURPM")
knitr::kable(PURPM)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

```{r icesPURPM}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import PURPM.
dbWriteTable(con_diaspara, "PURPM", PURPM)
dbExecute(con_diaspara, 'ALTER TABLE "PURPM" SET SCHEMA ref;')
dbExecute(con_diaspara, 
          'ALTER TABLE ref."PURPM" ADD CONSTRAINT purm_pkey PRIMARY KEY ("Key");')    
```

### DTYPE

```{r tbl-icesStation_DTYPE}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show icesStation_DTYPE.
#| tbl-cap: Station dictionary data type
Station_DTYPE <- getCodeList("Station_DTYPE")
knitr::kable(Station_DTYPE)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

```{r icesStation_DTYPE}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import icesStation_DTYPE.

dbWriteTable(con_diaspara, "Station_DTYPE", Station_DTYPE)
dbExecute(con_diaspara, 'ALTER TABLE "Station_DTYPE" SET SCHEMA ref;')  
dbExecute(con_diaspara, 
          'ALTER TABLE ref."Station_DTYPE" ADD CONSTRAINT station_dtype_pkey PRIMARY KEY ("Key");') 
```

### WLTYP

```{r tbl-icesStation_WLTYP}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show ices WLTYP.
#| tbl-cap: Water and Land Station Type
WLTYP <- getCodeList("WLTYP")
knitr::kable(WLTYP)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```
```{r icesStation_WLTYP}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import ices WLTYP.

dbExecute(con_diaspara, 'DROP TABLE IF EXISTS ref."WLTYP";')
WLTYP$Key[is.na(WLTYP$Key)] <- "NA"
dbWriteTable(con_diaspara, "WLTYP", WLTYP)
dbExecute(con_diaspara, 
          'ALTER TABLE "WLTYP" SET SCHEMA ref;') 
dbExecute(con_diaspara, 
          'ALTER TABLE ref."WLTYP" ADD CONSTRAINT wltype_pkey PRIMARY KEY ("Key");') 

```

### MSTAT

```{r tbl-icesStation_MSTAT}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show ices MSTAT.
#| tbl-cap: Type of monitoring station


MSTAT <- getCodeList("MSTAT")
knitr::kable(MSTAT)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

```{r icesStation_MSTAT}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import ices MSTAT.
dbWriteTable(con_diaspara, "MSTAT", MSTAT)
dbExecute(con_diaspara, 
          'ALTER TABLE ref."MSTAT" ADD CONSTRAINT mstat_pkey PRIMARY KEY ("Key");')   
```


### Deprecated


```{r tbl-icesStation_Deprecated}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show ices Deprecated.
#| tbl-cap: Deprecated
Deprecated <- getCodeList("Deprecated")
knitr::kable(Deprecated)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Habitat

THe habitat database is managed by [EIONET](http://dd.eionet.europa.eu/vocabulary/art17_2018/habitats/)
Habitats directive Art. 17 reporting in year 2018.
This is only for Natura2000 sites, a better options would be
https://eunis.eea.europa.eu/habitats-code-browser.jsp

<details>

<summary>SQL code to create tables</summary>

``` {.sql include="../SQL/metric_03_ref_tr_habitat_hab.sql"}
```

</details>

:::{.questionbox}
::::{.questionbox-header}
:::::{.questionbox-icon}
:::::
ICES / DIASPARA is this enough ?
::::
::::{.questionbox-body}
The idea was to have estuaries and lagoons, but rivers are associated with vegetation, 
So I''m not sure if this vocab is enough ?
::::
:::


```{r habitat}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import habitat from eionet.


# Load required libraries
library(XML)

# Parse the XML file downloaded from https://dd.eionet.europa.eu/vocabulary/art17_2018/habitats/codelist
xml_file <- "R/data/habitats.xml" # Replace with your actual file path
#file.exists("R/data/habitats.xml")
xml_data <- XML::xmlParse(xml_file)

# Extract all <value> nodes
values <- getNodeSet(xml_data, "//value")

# Extract relevant data into a data frame
extract_info <- function(node) {
  id <- XML::xmlGetAttr(node, "id")
  code <- gsub("http://dd.eionet.europa.eu/vocabulary/art17_2018/habitats/",
               x= id,replacement = "")
  label <- XML::xmlValue(node[["label"]])
  #defintion <- XML::xmlValue(node[["defintion"]])
  status_node <- XML::getNodeSet(node, ".//status/label")[[1]]
  status <- XML::xmlValue(status_node)
  return(data.frame(id = id, code = code, label = label,
                    status = status, stringsAsFactors = FALSE))
}

habitat <- do.call(rbind, lapply(values, extract_info))
habitat <- habitat[c(1:32,77:84,125:142),]

# Save the data frame as an RData file
save(habitat, file = "habitat_art_17_2018.RData")
# load(file = "habitat_art_17_2018.RData")
dbExecute(con_diaspara, 'DELETE FROM ref.tr_habitat_hab;')

dbWriteTable(con_diaspara, "habitat_temp", habitat)

dbExecute(con_diaspara, 
          'INSERT INTO "ref".tr_habitat_hab SELECT code, label, id, NULL,
 NULL, NULL FROM habitat_temp;') #58
dbExecute(con_diaspara, "DROP TABLE habitat_temp")#0

```

```{r tbl-habitat}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show habitat table (to be imported in ICES vocab).
#| tbl-cap: Habitat table ?

habitat <- dbGetQuery(con_diaspara, "SELECT * FROM ref.tr_habitat_hab;")
knitr::kable(habitat)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Fishway type ref.tr_fishway_fiw


<details>

<summary>SQL code to create table `tr_fishway_fiw` </summary>

``` {.sql include="../SQL/metric_04_ref_tr_fishway_fiw.sql"}
```

</details>


```{r tbl-fishway}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show fishway table (to be imported in ICES vocab).
#| tbl-cap: Fishway vocab proposed to ICES.

habitat <- dbGetQuery(con_diaspara, "SELECT * FROM ref.tr_fishway_fiw;")
knitr::kable(habitat)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Fish migration monitoring  ref.tr_monitoring_mon


<details>

<summary>SQL code to create table `tr_monitoring_mon`</summary>

``` {.sql include="../SQL/metric_05_ref_tr_monitoring_mon.sql"}
```

</details>


```{r tbl-monitoring}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show fishway table (to be imported in ICES vocab).
#| tbl-cap: Fishway vocab proposed to ICES.

habitat <- dbGetQuery(con_diaspara, 
                      "SELECT * FROM ref.tr_monitoring_mon;")
knitr::kable(habitat)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Fish Traits  ref.tr_trait_tra

This one was formerly called metric, but metric `ref.tr_metric_met` already exist and is better
suited to statistics (mean, sd ... ). So we are using the word trait.
Trait is refering to a species (there are different method,
or different measurements for different species).
The trait can be, either qualitative or quantitative.
The trait is measured by a method, the measure (either categorical
eg. sex = 'Male') or quantitative e.g. (length_mm = 150) might be accompanied by a method.
For instance a fish is measured for length as fork length or total length,
in the individual_trait table, the fish will be related to three columns,
the code of the length parameter in the trait table, the quantitative value,
and the method used.

<details>

<summary>SQL code to create tables `ref.tr_trait_tra` and refeel.tg_trait_tra</summary>

``` {.sql include="../SQL/metric_06_ref_tr_trait_tra.sql"}
```

</details>

:::{.callout-warning appearance="simple"}
## refeel.tg_trait_tra and ref.tr_trait_tra have different structures.
The first has nothing inside, it's a shell for inheritance.
Tables `ref.tr_traitnumeric_trn` and `ref.tr_traitqualitative_trq` are inherited from `ref.tr_trait_tra`.
They in turn are inherited from tables `refeel.tr_traitnumeric_trn` and `refeel.tr_traitqualitative_trq`.
So the values entered in `refeel.tr_traitqualitative_trq` appear when running a select query from
`ref.tr_trait_tra` even if they are not physically in these tables, and foreign key constraint
to `ref.tr_trait_tra` would return no value there.
Now if I inherit `refeel.tr_trait_tra` the values will get to `ref.tr_trait_tra` from two sources
and I will double the lines there. Also, physically data are not there. So I still cannot
use it as a reference table. So the table refeel.tg_trait_tra is not inherited, it's a grouping
table with the values actually physically there.
:::

## Numeric fish trait (tr_traitnumeric_trn)

Trait can be either qualitative or quantitative (numeric). Both tables are inherited from 
`tr_trait_tra`. 

<details>

<summary>SQL code to create tables `ref.tr_traitnumeric_trn` and `refeel.tr_traitnumeric_trn` </summary>

``` {.sql include="../SQL/metric_06_ref_tr_traitnumeric_trn.sql"}
```




```{r refeel_tr_traitnumeric_trn_insert}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import numeric trait.

tra <- dbGetQuery(con_wgeel_local, "SELECT * FROM ref.tr_metrictype_mty ;")
# we will include group metric names later
tra <- tra[(!grepl("mean", tra$mty_name) | 
              tra$mty_name =='eye_diam_meanmm' |
              tra$mty_name == 'teq'),]
# we will also include method later
tra <- tra[!grepl("method", tra$mty_name),]
res <- dbGetQuery(con_diaspara, "SELECT * FROM ref.tr_trait_tra")
#clipr::write_clip(colnames(res))
tranum <- data.frame(
  "tra_id" = tra$mty_id,
  "tra_code" = stringi::stri_trans_totitle(tra$mty_name),
  "tra_description" = tra$mty_description,
  "tra_wkg_code" = 'WGEEL',
  "Tra_spe_code" = 'ANG',
  "trn_uni_code" = tra$mty_uni_code,
  "tra_typemetric"=stringi::stri_trans_totitle(tra$mty_group),
  "tra_qualitativeornumeric"='Numeric',
  "trn_minvalue" = tra$mty_min,
  "trn_maxvalue" = tra$mty_max)


# the proportions will be numeric for group and qualitative for individual (
# e.g. evex presence)

tranum[tranum$tra_typemetric=="Both" & grepl("proportion",tranum$tra_code),
       c("tra_typemetric")] <- "Group"


# view(tranum)
# fix names
tranum$tra_description[tranum$tra_code=="Lengthmm"] <-
  'Total body length in millimeters (mm) or mean total body length for group'
tranum$tra_description[tranum$tra_code=="Differentiated_proportion"] <-
  'Proportion of differentiated eel (between 0 and 1)'

tranum$tra_description[tranum$tra_code=="Female_proportion"] <-
  'Female proportion in the population female/(male+female) for group (between 0 and 1)'
tranum$tra_description[tranum$tra_code=="Anguillicola_proportion"] <-
  'Prevalence of Anguillicola in proportion in group (between 0 and 1)'
tranum$tra_description[tranum$tra_code=="Evex_proportion"] <-
  'EVE and EVEX proportion in the group (between 0 and 1)'
tranum$tra_description[tranum$tra_code=="Hva_proportion"] <-
  'HVA proportion in the group (between 0 and 1)'
# duplicated, now two methods
tranum <- tranum[tranum$tra_id!=11,] 
tranum$tra_description[tranum$tra_id==10] <-
  "Lipid percentage or mean muscle lipid percentage for group"
tranum[tranum$tra_id==10,"tra_code"] <- "Muscle_lipid"

dbWriteTable(con_diaspara_admin, "tr_traitnumeric_trn_temp", tranum, overwrite =TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM refeel.tr_traitnumeric_trn")
dbExecute(con_diaspara_admin, "INSERT INTO refeel.tr_traitnumeric_trn(
tra_id,
tra_code,
tra_wkg_code,
tra_spe_code,
tra_description,
tra_typemetric,
trn_uni_code,
tra_qualitativeornumeric,
trn_minvalue,
trn_maxvalue)
SELECT 
tra_id,
tra_code,
'WGEEL',
'ANG',
tra_description,
tra_typemetric,
trn_uni_code,
tra_qualitativeornumeric,
trn_minvalue,
trn_maxvalue
 FROM tr_traitnumeric_trn_temp") #18


dbExecute(con_diaspara_admin, 
          "INSERT INTO refeel.tr_traitnumeric_trn (tra_id,tra_code,tra_description,
 tra_wkg_code,tra_spe_code,tra_typemetric,tra_qualitativeornumeric,
 trn_uni_code,trn_minvalue,trn_maxvalue)
	VALUES (27,'Eye_diam_vert_mm','Eye diameter (vertical) in mm','WGEEL',
  'ANG','Individual','Numeric','mm',1,15);
INSERT INTO refeel.tr_traitnumeric_trn (tra_id,tra_code,tra_description,
tra_wkg_code,tra_spe_code,tra_typemetric,tra_qualitativeornumeric,
trn_uni_code,trn_minvalue,trn_maxvalue)
	VALUES (28,'Eye_diam_horiz_mm','Eye diameter (horizontal) in mm',
  'WGEEL','ANG','Individual','Numeric','mm',1,15);
") #18


dbExecute(con_diaspara_admin,  "UPDATE refeel.tr_traitnumeric_trn
	SET tra_code='Eye_diam_mean_mm'
	WHERE tra_id=4;")

```


```{r}
#| label: tbl-refeel.tr_traitnumeric_trn
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show trait numeric table.
#| tbl-cap: Quantitative parameters parameters
dbGetQuery(con_diaspara, "SELECT * FROM refeel.tr_traitnumeric_trn;") |>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```

</details>

## Qualitative fish trait (tr_traitqualitative_trq)

<details>

<summary>SQL code to create table `ref.tr_traitqualitative_trq` and `refeel.tr_traitqualitative_trq` </summary>

``` {.sql include="../SQL/metric_06_ref_tr_traitqualitative_trq.sql"}
```
</details>

```{r refeel_tr_traitqualitative_trq_insert}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import qualitative table.

tra <- dbGetQuery(con_wgeel_local, "SELECT * FROM ref.tr_metrictype_mty ;")
# we will include group metric names later
tra <- tra[grepl("is_", tra$mty_individual_name) |
             grepl("presence", tra$mty_individual_name),]
# we will also include method later

#clipr::write_clip(colnames(res))
traqal <- data.frame(
  "tra_id" = tra$mty_id,
  "tra_code" = stringi::stri_trans_totitle(tra$mty_individual_name),
  "tra_description" = tra$mty_description,
  "tra_wkg_code" = 'WGEEL',
  "Tra_spe_code" = 'ANG',
  "tra_uni_code" = tra$mty_uni_code,
  "tra_typemetric"='Individual',
  "tra_qualitativeornumeric"='Qualitative'
)


# the proportions will be numeric for group and qualitative for individual (
# e.g. evex presence)

traqal$tra_code <- gsub("\\s*_\\([^\\)]+\\)", "", traqal$tra_code)
traqal$tra_code[traqal$tra_code=="Is_female"] <- "Sex"
traqal$tra_individualname <- traqal$tra_code

# fix names

traqal$tra_description[traqal$tra_code=="Is_differentiated"] <- 
  'Is the eel differentiated (Y Yes, N No, NA Not applicable,P probable, U Unknown)'
traqal$tra_description[traqal$tra_code=="Sex"] <-
  'Sex (F Female,
 H Hermaphordite,
I Immature attempt made,M Male, 
T Transitional, 
U Undetermined no attempt made, 
X Mixed)'
traqal$tra_description[traqal$tra_code=="Anguillicola_presence"] <-
  'Presence of Anguillicola (Y Yes, N No, NA Not applicable,P probable, U Unknown)'
traqal$tra_description[traqal$tra_code=="Evex_presence"] <-
  'EVE or EVEX presence (Y Yes, N No, NA Not applicable,P probable, U Unknown)'
traqal$tra_description[traqal$tra_code=="Hva_presence"] <-
  'HVA presence (Y Yes, N No, NA Not applicable,P probable, U Unknown)'
# view(traqal)

dbWriteTable(con_diaspara_admin, "tr_traitqualitative_trq_temp",
             traqal, overwrite =TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM refeel.tr_traitqualitative_trq");
dbExecute(con_diaspara_admin, "INSERT INTO refeel.tr_traitqualitative_trq(
tra_id,
tra_code,
tra_wkg_code,
tra_spe_code,
tra_description,
tra_typemetric,
tra_qualitativeornumeric)
SELECT 
tra_id,
tra_code,
'WGEEL',
'ANG',
tra_description,
tra_typemetric,
tra_qualitativeornumeric
 FROM tr_traitqualitative_trq_temp") #5
# TODO add group name


dbExecute(con_diaspara_admin, "INSERT INTO refeel.tr_traitqualitative_trq(
tra_id,
tra_code,
tra_wkg_code,
tra_spe_code,
tra_description,
tra_typemetric,
tra_qualitativeornumeric)
SELECT 
29,
'Pigment_stage',
'WGEEL',
'ANG',
'Pigmentation stage according to Elie, 1982',
'Individual',
'Qualitative'") 
# duplicated for variables which were both group and 
dbExecute(con_diaspara_admin,
          "UPDATE refeel.tr_traitqualitative_trq SET tra_id = 34 
 WHERE tra_code='Hva_presence';")
dbExecute(con_diaspara_admin, 
          "UPDATE refeel.tr_traitqualitative_trq SET tra_id = 33 
WHERE tra_code='Evex_presence';")
dbExecute(con_diaspara_admin, 
          "UPDATE refeel.tr_traitqualitative_trq SET tra_id= 32 
WHERE tra_code='Anguillicola_presence';")
dbExecute(con_diaspara_admin, 
          "UPDATE refeel.tr_traitqualitative_trq SET tra_id= 31 
WHERE tra_code='Is_differentiated'")
dbExecute(con_diaspara_admin,
          "UPDATE refeel.tr_traitqualitative_trq SET tra_id= 30 
 WHERE tra_code='Sex';")
```

```{r}
#| label: tbl-tr_traitqualitative_trq
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show qualitative trait table.
#| tbl-cap: Qualitative parameters
dbGetQuery(con_diaspara,
           "SELECT * FROM refeel.tr_traitqualitative_trq;") |> 
  knitr::kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```



## Values of Qualitative fish trait (tr_traitvaluequal_trv)

The qualitative traits have a limited set of discrete values, 
this table contains the discrete values.


<details>

<summary>SQL code to create tables `ref.tr_traitqualvalue_trv` and `refeel.tr_traitqualvalue_trv`</summary>

``` {.sql include="../SQL/metric_08_ref_tr_traitvaluequal_trv.sql"}
```
</details>



```{r tbl-refeel_tr_traitvalueqal_trv}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import trait values for qualitative parm.
#| tbl-cap: Table of possible qualitative trait values

trv <- dbGetQuery(con_diaspara, "SELECT * FROM refeel.tr_traitvaluequal_trv;")
trq <- dbGetQuery(con_diaspara, "SELECT * FROM refeel.tr_traitqualitative_trq;")
#clipr::write_clip(colnames(trv))
trq <- data.frame(
  "trv_id"=1:(13+5*4+7),
  "trv_trq_code"=c(
    rep(trq$tra_code[1],13),
    rep(trq$tra_code[2],5),
    rep(trq$tra_code[3],5),
    rep(trq$tra_code[4],5),
    rep(trq$tra_code[5],5),
    rep(trq$tra_code[6],7)),
  "trv_code"=c(c("VA","VB","VIA0","VIA1","VIA2",
                 "VIA3","VIA4","VIB","VII", "mix_VIA1_VIA4",
                 "mix_VA_VB", "U","NA"),
               rep(c("N","NA","U","Y","P"),4),
               c("F","I","M","T","U","X","H")),
  "trv_description" = c(
    "No pigmentation except a spot on the caudal fin",
    "Early development of the pigmentation on the skull,
   no superficial piment beyond the cerebral spot.",
   "Development of dorsal pigmentation along the base of dorsal fin",
   "The dosal pigmentation is complete from head to tail",
   "Presence of medio lateral pigmentation but
   it does not reach the beginning of the dorsal fin",
   "The medio-lateral pigmentation reaches the beginning of the dorsal fin",
   "Ventro lateral pigmentation distributed along the myosepta. 
  Pigments are still distinct.",
  "Pigments are no longer distinct in the ventro lateral region",
  "Loss of transparency, the abdominal cavity takes a silvery color.
  Generalised development of yellow eel pigment cells",
  "Development of surface and branchiostegal pigmentation",
  "No or early pigmentation",
  "Glass eels, but pigmentation stage is unknown",
  "Not available",
  rep(c("No","Not Applicable", "Unknown","Yes", "Probable"), 4),
  "Female", "Immature - attempt made but sex could not be destinguished",
  "Male", "Transitional", "Undetermined - no attempt made", "Mixed",
  "Hermaphrodite"
  ))
dbWriteTable(con_diaspara_admin, "tr_traitvaluequal_trv_temp", trq,
             overwrite =TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM refeel.tr_traitvaluequal_trv");
dbExecute(con_diaspara_admin, "INSERT INTO refeel.tr_traitvaluequal_trv
SELECT 
trv_id,
trv_trq_code,
trv_code,
trv_description,
'WGEEL',
'ANG'
 FROM tr_traitvaluequal_trv_temp;") #40

```

```{r}
#| label: tbl-tr_traitvalueqal_trv
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show trait value table.
#| tbl-cap: Values for qualitative parameters
dbGetQuery(con_diaspara, "SELECT * FROM refeel.tr_traitvaluequal_trv;") |>
  knitr::kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```




## Fish trait measurement method

Currently in the wgeel database, the metrics table value contains one column for value which can store numeric or integer. When it is integer, then, the metric id (mty_id) refers either to a category (e.g sex, or is differenciated), or a method (sexed using size, sexed after gonadal inspection). 
In the new database, the method will be stored in a different column in the group or individual metrics. This table references the methods proposed.
Again these methods will be working group specific so we create an inherited table.

<details>

<summary>SQL code to create tables `ref.tr_traitmethod_trm` and `refeel.tr_traitmethod_trm`</summary>

``` {.sql include="../SQL/metric_07_ref_tr_traitmethod_trm.sql"}
```

</details>


```{r ref_tr_traitmethod_trm_insert}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import traitmethod table.

tra <- dbGetQuery(con_wgeel_local, "SELECT * FROM ref.tr_metrictype_mty ;")
tra <- tra[grepl("method", tra$mty_name), ]
res <- dbGetQuery(con_diaspara, "SELECT * FROM ref.tr_traitmethod_trm")
clipr::write_clip(colnames(res))
traitmethod <- data.frame(
  "trm_id" = 1:6,
  "trm_tra_code" = c(
    "Gonadal_inspection",
    "Length_based_sex",
    "Anguillicola_stereomicroscope_count",
    "Anguillicola_visual_count",       
    "Muscle_lipid_fatmeter",
    "Muscle_lipid_gravimeter"
  ),
  "trm_wkg_code" = rep("WGEEL", 6),
  "trm_spe_code" = rep("ANG", 6),
  "trm_description" = c(
    "The eel is dissected and the gonads are inpected, 
    In males, the testes  appear as thin, ribbon-like, whitish structures. 
    In females, the ovaries are larger, lobed, and more granular,
     often yellowish or pinkish depending on maturity. 
     Many eels pass through an intersexual phase
      (Here refered as Mixed to align with ICES Vocab), 
      where gonads show both ovarian and testicular tissue. 
      This is part of their natural development", # nolint
    "The size at silvering of eels depends on the sex. 
    Males are found within the 25-45 cm range, and females are found over 45 cm.
     There is an overlap of sexes arround ",# nolint
    "Anguillicola count using a dissecting microscope,
     this allows to detect early-stage infections or small larvae",
    "Anguillicola visual count",
    "Non invasive estimation of the fat content 
    by measuring the dielectric properties of tissues, 
    this method requires a calibration.",# nolint
    "Gravimeter, muscle tissues are dried and the lipids 
    are extracted using solvents, the extracted fat is dried and weighted" # nolint
  )
)

dbWriteTable(con_diaspara_admin, "tr_traitmethod_trm_temp", traitmethod, overwrite = TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM refeel.tr_traitmethod_trm")
dbExecute(con_diaspara_admin, "INSERT INTO refeel.tr_traitmethod_trm
SELECT
trm_id,
trm_tra_code,
trm_wkg_code,
trm_spe_code,
trm_description
 FROM tr_traitmethod_trm_temp") # 6
```

```{r tbl-ref_tr_traitmethod_trm}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show trait measurement method table.
#| tbl-cap: Trait table, check how this will be imported ...

trm <- dbGetQuery(con_diaspara, "SELECT * FROM ref.tr_traitmethod_trm;")
knitr::kable(trm)|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```


## Creating the station table

Series will be linked to one or several stations.

The station are loaded into a table that will not be
exactly like ICES's since I cannot load the full tables, and don't want to replicate the full complexity of stations. For instance currently station 1000 has several parents for "Station_DTYPE" which I agregate like EW~EU~NU~CW,
in my table. But the vocab is here.


<details>

<summary>SQL code to create tables</summary>

``` {.sql include="../SQL/metric_01_StationDictionary.sql"}
```

</details>


We have to do some fixes see (issue 27)[https://github.com/ices-tools-prod/icesVocab/issues/27] and remove nearly all the constraints, including the length of 50 for stationNames.
The following chunk creates a vocab with 14086 stations.


```{r ices_Station}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import station

# tested 28/05/2025

library(icesStation)
system.time(
  station <- getListStation())
# user     system      spent
#    268.09        9.06     1402.47 
save(station, file = "data/station.Rdata")
# load(file = "data/station.Rdata")
initcap <- function(X) paste0(substring(X,1,1),tolower(substring(X,2, length(X))))


station <- station[station$Station_Name != 'TestBulkUload1',]
station$Station_Deprecated<- initcap(as.character(station$Station_Deprecated))

dbWriteTable(con_diaspara_admin, "temp_station", station, overwrite = TRUE)
dbExecute(con_diaspara_admin,'DELETE FROM "ref"."StationDictionary"')
dbExecute(con_diaspara_admin,'INSERT INTO "ref"."StationDictionary"
("Definition", 
"HeaderRecord", 
"Station_Code",
 "Station_Country",
 "Station_Name",
 "Station_LongName", 
"Station_ActiveFromDate", 
"Station_ActiveUntilDate",
 "Station_ProgramGovernance",
 "Station_StationGovernance", 
"Station_PURPM",
 "Station_DataType",
 "Station_WLTYP",
 "Station_MSTAT", 
"Station_Notes", 
"Station_Deprecated")
SELECT
"Definition", 
"HeaderRecord", 
"Station_Code"::INTEGER,
 "Station_Country",
 "Station_Name",
 "Station_LongName", 
"Station_ActiveFromDate", 
"Station_ActiveUntilDate",
 "Station_ProgramGovernance",
 "Station_StationGovernance", 
"Station_PURPM",
 "Station_DataType",
 "Station_WLTYP",
 "Station_MSTAT", 
"Station_Notes", 
"Station_Deprecated" 
 FROM temp_station') #14086
dbExecute(con_diaspara_admin, "DROP TABLE if exists temp_station")

```



```{r ices_Station_import}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import station

# tested 28/05/2025

library(icesStation)
system.time(
  station <- getListStation())
#      user     system      spent
#    268.09        9.06     1402.47 
save(station, file = "data/station.Rdata")
# load(file = "data/station.Rdata")
initcap <- function(X) paste0(substring(X,1,1),tolower(substring(X,2, length(X))))


station <- station[station$Station_Name != 'TestBulkUload1',]
station$Station_Deprecated<- initcap(as.character(station$Station_Deprecated))

dbWriteTable(con_diaspara_admin, "temp_station", station, overwrite = TRUE)
dbExecute(con_diaspara_admin,'DELETE FROM "ref"."StationDictionary"')
dbExecute(con_diaspara_admin,'INSERT INTO "ref"."StationDictionary"
("Definition", 
"HeaderRecord", 
"Station_Code",
 "Station_Country",
 "Station_Name",
 "Station_LongName", 
"Station_ActiveFromDate", 
"Station_ActiveUntilDate",
 "Station_ProgramGovernance",
 "Station_StationGovernance", 
"Station_PURPM",
 "Station_DataType",
 "Station_WLTYP",
 "Station_MSTAT", 
"Station_Notes", 
"Station_Deprecated")
SELECT
"Definition", 
"HeaderRecord", 
"Station_Code"::INTEGER,
 "Station_Country",
 "Station_Name",
 "Station_LongName", 
"Station_ActiveFromDate", 
"Station_ActiveUntilDate",
 "Station_ProgramGovernance",
 "Station_StationGovernance", 
"Station_PURPM",
 "Station_DataType",
 "Station_WLTYP",
 "Station_MSTAT", 
"Station_Notes", 
"Station_Deprecated" 
 FROM temp_station') #14086
dbExecute(con_diaspara_admin, "DROP TABLE if exists temp_station")

```


:::{.callout-important appearance="simple"}
## Comment on Station import
Even though a table station exists in WGEEL, it really contains no actual code from ICES. 
To insert data into stations, the data providers will have to check that they have an EDMO code, and then we will have to bulk load stations.
:::



## Creating the version table refeel.tr_version_ver

<details>

<summary>SQL code to create table `refeel.tr_version_ver`</summary>

``` {.sql include="../SQL/metric_02_refeel_tr_version_ver.sql"}
```

</details>


This table is the same as in wgnas, it is inherited from ref.

```{r }
#| label: refeel_tr_version_ver_insert
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to insert values into the tr_version_ver table



# get the latest version from the server
ver <- dbGetQuery(con_wgeel_distant, "select * from ref.tr_datasource_dts")
save(ver, file= "data/tr_datasource_dts.Rdata")
ver <- ver[ver$dts_datasource != 'test',]
dc <- ver[grepl("dc", ver$dts_datasource), "dts_datasource"]
dcyear <- as.integer(lapply(strsplit(dc,"_"), function(X)X[2]))
wgeel <- ver[grepl("wgeel", ver$dts_datasource), "dts_datasource"]
wgeelyear <- as.integer(lapply(strsplit(wgeel,"_"), function(X)X[2]))
tr_version_ver <- data.frame(
  ver_code = paste0(rep("ANG-", 11),
                    c(wgeelyear, dcyear, 2025),c("-1","-2",rep("-1", 9))),
  ver_year = c(wgeelyear, dcyear, 2025,2025),
  ver_spe_code = "ANG",
  ver_datacalldoi=c(rep(NA, 10), 
                    "https://doi.org/10.17895/ices.pub.25816738.v2",
                    "https://doi.org/10.17895/ices.pub.25816738.v2",
                    "https://doi.org/10.17895/ices.pub.29254589"), 
  ver_stockkeylabel =c("ele.2737.nea"), 
  ver_version=c(1,2,rep(1,19),2), 
  ver_description=ver$dts_description) # 

DBI::dbWriteTable(con_diaspara_admin, "temp_tr_version_ver", tr_version_ver, 
                  overwrite = TRUE)
dbExecute(con_diaspara_admin, 
          "INSERT INTO refeel.tr_version_ver(ver_code,ver_year,ver_spe_code,
 ver_datacalldoi,ver_stockkeylabel,ver_version, ver_description) 
 SELECT ver_code,ver_year,ver_spe_code, ver_datacalldoi,
 ver_stockkeylabel,ver_version, ver_descriptio FROM temp_tr_version_ver;") # 5
DBI::dbExecute(con_diaspara_admin, "DROP TABLE temp_tr_version_ver;")


```


```{r}
#| label: tbl-version-refeel
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| tbl-cap: Version

dbGetQuery(con_diaspara, "SELECT * FROM refeel.tr_version_ver;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```

## series table t_series_ser




### Creating series main table for series


<details>

<summary>SQL code to create table `dat.t_series_ser` </summary>

``` {.sql include="../SQL/metric_10_dat_t_series_ser.sql"}
```

</details>

This table is inherited so the table created in dat will be empty, and will
only receive data by inheritance. It can be considered as a view for ICES (no 
inheritance in SQL server).

Since this table is inherited the wkg needs to be included. One table will be created
per working group. These tables will be collated together.
Most details information about metadata will be in the metadata tables, either
to describe annual sampling or to describe individual metric collection.

Monitoring stations (including fixed stations) that are used for recurring sampling or data collection are managed via the Station Code Request Application in ICES [@ices_vocab_2024].
This table will reference monitoring station but it might be NULL, as some sampling 
designs or data collection, for instance for the DCF, are not related to a station.


:::::: questionbox
:::: questionbox-header
::: questionbox-icon
:::

QUESTION ICES (Cédric via Teams meeting)
::::

::: questionbox-body
The ser_id might in some cases correspond to a fixed station but not only. For this reason 
the station is referenced here but another code will be created to reference the
sampling collection. Is this OK ?
:::
::::::


:::::: answerbox
:::: answerbox-header
::: answerbox-icon
:::

ANSWER ICES : Maria (20/05/2025)
::::

::: answerbox-body
Yes this makes sense,  I would advise 
to use both the stations and a unique identifier at the top. Using UUID will help
unicity there. It's not clear if it needs to 
be a vocabulary. 
There is a procedure to integrate stations, but for this we will probably do a bulk import.
:::
::::::

:::{.callout-note appearance="simple"}
## QUESTION to DIASPARA
I this that many of our series, and many of BAST or NAS would be related to fishways.
Shouldn't we need a fishway / fishway monitoring device vocab there ?
:::

:::{.callout-note appearance="simple"}
## QUESTION to WKEELDATA
Currently everything is in the same table, but it could be split by period
following exactly the station work. 
A description would then spans a limited amount of year from
date_begin to date_end. If the series description still hold the date_end is null.
If so we need to decide what fields could change over time (if any)
:::


### Creating inherited series


<details>

<summary>SQL code to create table `dateel.t_series_ser`</summary>

``` {.sql include="../SQL/metric_11_dateel_t_series_ser.sql"}
```

</details>




### Import t_series_ser from wgeel

```{r refeel.t_series_ser_import}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import to to refeel.tr_series_ser

res <- dbGetQuery(con_diaspara, "SELECT * FROM dateel.t_series_ser")
clipr::write_clip(colnames(res))

# temporarily remove area constraint

dbExecute(con_diaspara_admin, "ALTER TABLE dateel.t_series_ser drop constraint 
fk_ser_are_code")
dbExecute(con_diaspara_admin, "ALTER TABLE dateel.t_series_ser ALTER COLUMN  
ser_are_code DROP NOT NULL")
dbExecute(con_diaspara_admin, "ALTER TABLE dateel.t_series_ser ALTER COLUMN  
ser_cou_code DROP NOT NULL")
dbExecute(con_diaspara_admin, 
          "ALTER TABLE dateel.t_series_ser DROP CONSTRAINT uk_ser_name")

t_series_ser <-
  data.frame(
    "ser_id" = uuid::UUIDgenerate(n=nrow(ser)),
    "ser_code" = ser$ser_nameshort,
    "ser_name"  = ser$ser_namelong,
    "ser_spe_code" = "ANG",
    "ser_lfs_code" = ser$ser_lfs_code,
    "ser_are_code" = ser$ser_emu_nameshort,
    "ser_wkg_code" = "WGEEL",
    "ser_ver_code" = case_when(ser$ser_dts_datasource =="dc_2019" ~ "ANG-2019-1",
                               ser$ser_dts_datasource =="dc_2021" ~ "ANG-2021-1",
                               ser$ser_dts_datasource =="dc_2022" ~ "ANG-2022-1",
                               ser$ser_dts_datasource =="dc_2023" ~ "ANG-2023-1",
                               ser$ser_dts_datasource =="dc_2024" ~ "ANG-2024-1",
                               .default = "ANG-2018-1"),
    "ser_cou_code" = ser$ser_cou_code,
    "ser_hab_code" = NA,
    "ser_gea_code" = ser$gea_issscfg_code,
    "ser_fiw_code" = NA,
    "ser_mon_code" = NA,
    "ser_uni_code" = ser$ser_uni_code,
    "ser_effort_uni_code" = ser$ser_effort_uni_code,
    "ser_description" = ser$ser_comment,
    "ser_locationdescription" = ser$ser_locationdescription,
    "ser_wltyp_code" = case_when(ser$ser_hty_code == "T" ~ "T",
                                 ser$ser_hty_code == "C" ~ "MC",
                                 ser$ser_hty_code == "F" ~ "FW",
                                 ser$ser_hty_code == "MO" ~ "MO"),
    "ser_stocking" = ser$ser_restocking,
    "ser_stockingcomment" = NA,
    "ser_protocol" = ser$ser_method,
    "ser_samplingstrategy" = NA,
    "ser_datarightsholder" = NA,
    "ser_datelastupdate" = '2025-06-09',
    "geom" = ser$geom    
  )

res <- dbWriteTable(con_diaspara_admin, "t_series_ser_temp", 
                    t_series_ser, overwrite = TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM  dateel.t_series_ser;")
dbExecute(con_diaspara_admin, "INSERT INTO dateel.t_series_ser 
SELECT 
 ser_id::uuid,
 ser_code,
 ser_name,
 ser_spe_code,
 ser_lfs_code,
 ser_are_code,
 ser_wkg_code,
 ser_ver_code,
 ser_cou_code,
 ser_hab_code,
 ser_gea_code,
 ser_fiw_code,
 ser_mon_code,
 ser_uni_code,
 ser_effort_uni_code,
 ser_description,
 ser_locationdescription,
 ser_wltyp_code,
 ser_stocking,
 ser_stockingcomment,
 ser_protocol,
 ser_samplingstrategy,
 ser_datarightsholder,
 ser_datelastupdate::date,
 geom
FROM t_series_ser_temp") # 294 

sai <- dbGetQuery(con_wgeel_distant, 
                  "SELECT sai.* FROM datawg.t_samplinginfo_sai sai;
")

t_series_ser2 <-
  data.frame(
    "ser_id" = uuid::UUIDgenerate(n=nrow(sai)),
    "ser_code" = sai$sai_id,
    "ser_name"  = sai$sai_name,
    "ser_spe_code" = "ANG",
    "ser_lfs_code" = NA,
    "ser_are_code" = NA, # TODO sai_emu_nameshort sai_area_division
    "ser_wkg_code" = "WGEEL",
    "ser_ver_code" = case_when(sai$sai_dts_datasource =="dc_2019" ~ "WGEEL-2019-1",
                               sai$sai_dts_datasource =="dc_2021" ~ "WGEEL-2021-1",
                               sai$sai_dts_datasource =="dc_2022" ~ "WGEEL-2022-1",
                               sai$sai_dts_datasource =="dc_2023" ~ "WGEEL-2023-1",
                               sai$sai_dts_datasource =="dc_2024" ~ "WGEEL-2024-1",
                               .default = "WGEEL-2018-1"),
    "ser_cou_code" = sai$sai_cou_code,
    "ser_hab_code" = NA,
    "ser_gea_code" = NA,
    "ser_fiw_code" = NA,
    "ser_mon_code" = NA,
    "ser_uni_code" = NA,
    "ser_effort_uni_code" = NA,
    "ser_description" = sai$sai_comment,
    "ser_locationdescription" = NA,
    "ser_wltyp_code" = case_when(sai$sai_hty_code == "T" ~ "T",
                                 sai$sai_hty_code == "C" ~ "MC",
                                 sai$sai_hty_code == "F" ~ "FW",
                                 sai$sai_hty_code == "MO" ~ "MO"),
    "ser_stocking" = NA,
    "ser_stockingcomment" = NA,
    "ser_protocol" = sai$sai_protocol,
    "ser_samplingstrategy" = sai$sai_samplingstrategy,
    "ser_datarightsholder" = NA,
    "ser_datelastupdate" = sai$sai_lastupdate,
    "geom" = NA # no geom in this table  
  )

res <- dbWriteTable(con_diaspara_admin, "t_series_ser_temp2", 
                    t_series_ser2, overwrite = TRUE)
dbExecute(con_diaspara_admin, "INSERT INTO dateel.t_series_ser 
SELECT 
 ser_id::uuid,
 ser_code,
 ser_name,
 ser_spe_code,
 ser_lfs_code,
 ser_are_code,
 ser_wkg_code,
 ser_ver_code,
 ser_cou_code,
 ser_hab_code,
 ser_gea_code,
 ser_fiw_code,
 ser_mon_code,
 ser_uni_code,
 ser_effort_uni_code,
 ser_description,
 ser_locationdescription,
 ser_wltyp_code,
 ser_stocking,
 ser_stockingcomment,
 ser_protocol,
 ser_samplingstrategy,
 ser_datarightsholder,
 ser_datelastupdate::date,
 NULL
FROM t_series_ser_temp2") # 252 

```

```{r}
#| label: tbl-dateel.t_series_ser
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show series table.
#| tbl-cap: Table t_series_ser for series first 20 lines
dbGetQuery(con_diaspara, "SELECT * FROM dateel.t_series_ser limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```


## Annual series table

This table holds annual data from the series.

<details>

<summary>SQL code to create table `dat.t_serannual_san`</summary>

``` {.sql include="../SQL/metric_20_dat_t_serannual_san.sql"}
```

</details>


## Creating inherited table for annual series


<details>

<summary>SQL code to create tables `dateel.t_serannual_san`</summary>

``` {.sql include="../SQL/metric_21_dateel_t_serannual_san.sql"}
```

</details>


## Import data for annual series 

Data are imported from WGEEL `datawg.t_dataseries_das`table to `dateel.t_serannual_ser`.

```{r dateel.t_serannual_ser}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import to dateel.t_serannual_ser

das0 <- dbGetQuery(con_wgeel_distant, "SELECT * FROM datawg.t_dataseries_das;
")

res <- dbGetQuery(con_diaspara, "SELECT * FROM dateel.t_serannual_san")
clipr::write_clip(colnames(res))

das0$das_dts_datasource[is.na(das0$das_dts_datasource)] <- "WGEEL-2016"
das0$das_dts_datasource <- 
  paste0(gsub(pattern = "dc_", replacement = "WGEEL-", 
              x= das0$das_dts_datasource), "-1")
das0$das_qal_id[is.na(das0$das_qal_id)] <- 1

nrow(das0) # 6523
das0 <- das0 |> filter(das0$das_qal_id <5)
nrow(das0) # 6402

ser <-  dbGetQuery(con_diaspara, 
                   "SELECT ser_id, ser_code FROM dateel.t_series_ser")
ser0 <- dbGetQuery(con_wgeel_distant, 
                   "SELECT ser_id, ser_nameshort as ser_code FROM datawg.t_series_ser ser;")

# adding ser_code to the series.
das <- das0 |> rename(ser_id = das_ser_id) |>
  inner_join(ser0) |> select(-ser_id) |> 
  inner_join(ser)
nrow(das) #6523

t_serannual_san_temp <-
  data.frame(
    "san_ser_id" = das$ser_id,
    "san_id" = das$das_id,
    "san_value"=das$das_value,
    "san_year" = das$das_year,
    "san_comment" = das$das_comment,
    "san_effort" = das$das_effort,
    "san_datelastupdate" = das$das_last_update,
    "san_qal_id" = das$das_qal_id,
    "san_qal_comment" = das$das_qal_comment,
    "san_wkg_code" = "WGEEL",
    "san_ver_code" = das$das_dts_datasource)


res <- dbWriteTable(con_diaspara_admin, "t_serannual_san_temp", 
                    t_serannual_san_temp, overwrite = TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM  dateel.t_serannual_san;")
dbExecute(con_diaspara_admin, "INSERT INTO dateel.t_serannual_san 
SELECT 
    san_ser_id::uuid,
    san_id,
    san_value,
    san_year,
    san_comment,
    san_effort,
    san_datelastupdate,
    san_qal_id,
    san_qal_comment,
    san_wkg_code,
    san_ver_code 
FROM t_serannual_san_temp") # 6402

``` 


```{r}
#| label: tbl-dateel.t_serannual_san
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show series table.
#| tbl-cap: Table t_serannual_san for annual values  first 20 lines
dbGetQuery(con_diaspara, "SELECT * FROM dateel.t_serannual_san limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Creating table joining series and station

The table is created but empty. We need the stations in ICES first.

<details>

<summary>SQL code to create table `dat.tj_seriesstation_ses`</summary>

``` {.sql include="../SQL/metric_12_dat.tj_seriesstation_ses.sql"}
```

</details>


## Creating inherited joining series and station


<details>

<summary>SQL code to create table `dateel.tj_seriesstation_ses`</summary>

``` {.sql include="../SQL/metric_13_dateel.tj_seriesstation_ses.sql"}
```

</details>

# Creating additional table for stock annex

## Creating table t_recruitmentmetadata

The code was developped during [WKEELDATA6](https://doi.org/10.17895/ices.pub.29290463)
Currently the table is not intended to be held in the db
There is still work to be done on the area referential for eel (starting summer 2025).
Some referentials are coming from the old db (emu, sampling type), and 
are currently not transfered.


<details>

<summary>SQL code to create table `dateel.t_recruitmentmetadata_met`</summary>

``` {.sql include="../SQL/metric_14_dateel_t_recruitmentmetadata_met.sql"}
```

</details>


```{r}
#| label: tbl-dateel.t_recruitmentmetadata_met
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show series metadata table.
#| tbl-cap: Table t_recruitmentmetadata_met for additional values collected during wkeeldata
dbGetQuery(con_diaspara, 
           "SELECT * FROM dateel.t_recruitmentmetadata_met limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```



# Creating group metrics

## Create group table

:::{.callout-note appearance="simple"}
## Note for group metrics
Need a foreign key on both species and lfs code.
:::

<details>

<summary>SQL code to create table `dat.t_group_gr`</summary>

``` {.sql include="../SQL/metric_22_dat_t_group_gr.sql"}
```

</details>

## Create group table for dateel

<details>

<summary>SQL code to create table `dateel.t_group_gr`</summary>

``` {.sql include="../SQL/metric_23_dateel_t_group_gr.sql"}
```

</details>

## Import data for group

Scripts differ a bit for series and sampling. Check for some series with comment
so see if need removing.

>  all related metrics have qal_id=22 following data call 2022


<details>

<summary>SQL code to Import data </summary>

``` {.sql include="../SQL/metric_24_dateel_t_group_gr_insert.sql"}
```

</details>



```{r}
#| label: tbl-dateel.t_group_gr
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show group table.
#| tbl-cap: Table t_group_gr, group related to annual values first 20 lines
dbGetQuery(con_diaspara, "SELECT * FROM dateel.t_group_gr limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

# Grouptrait table 

## Create table


<details>

<summary>SQL code to create tables `dat.t_grouptrait_grt` and `dateel.t_grouptrait_grt` </summary>

``` {.sql include="../SQL/metric_26_dat_t_grouptrait_grt.sql"}
```

</details>

## Import data 

![Mapping previous database for groups :This is how the mapping was done for groups, on the left the new db
with in red the fields for individual metric (not in group metrics),
on the right, the old db, with in oranges fields that need to be mapped to
method. In yellow the groups that now refer to subgroup by sex recreated at previous step](images/mapping_trait_and_mty.png)

<details>

<summary>SQL code to import data</summary>

``` {.sql include="../SQL/metric_27_dat_t_grouptrait_grt_import.sql"}
```

</details>

```{r}
#| label: tbl-dateel.t_grouptrait_grt
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show t_grouptrait_grt table.
#| tbl-cap: Table t_grouptrait_grt, group metrics (t_grouptrait_grt)
dbGetQuery(con_diaspara, "SELECT * FROM dateel.t_grouptrait_grt limit 20;")|> 
  knitr::kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

# Creating ind metrics 

## Fish table

<details>

<summary>SQL code to create tables `dat.t_fish_fi` and `dateel.t_fish_fi`</summary>

``` {.sql include="../SQL/metric_28_dat_t_fish_fi.sql"}
```

</details>

<details>

<summary>SQL code to import data tables</summary>

``` {.sql include="../SQL/metric_29_dat_t_fish_fi_insert.sql"}
```

</details>


```{r}
#| label: tbl-dateel.t_fish_fi
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show fish table.
#| tbl-cap: Table t_fish_fi, fish table
dbGetQuery(con_diaspara, "SELECT * FROM dateel.t_fish_fi limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Table t_indtrait_int

<details>

<summary>SQL code to create tables `dat.t_indivtrait_int` and `dateel.t_indivtrait_int` </summary>

``` {.sql include="../SQL/metric_30_dat_t_indivtrait_int.sql"}
```

</details>

<details>

<summary>SQL code to import individual metric tables</summary>

``` {.sql include="../SQL/metric_31_dat_t_indivtrait_int_insert.sql"}
```

</details>


```{r}
#| label: tbl-dateel.t_indivtrait_int
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show fish table.
#| tbl-cap: Table t_indivtrait_int, fish metric table
dbGetQuery(con_diaspara, "SELECT * FROM dateel.t_indivtrait_int limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

[TODO] Link the ccm wso_id to the hydroshed db identifiers of the basins to get the best fit from tr_area_are.
git issue #25 Import data from WGEEL](https://github.com/DIASPARAproject/WP3_migdb/issues/23)

The release date for that one is :

[Milestone release alpha](https://github.com/DIASPARAproject/WP3_migdb/milestone/5)

So the metric release will be after wgeel, the work will be finished and this can be presented during wgeel.

# Import data from WP2 (TODO)


# WGBAST


## series table t_series_ser


### Creating inherited series


<details>

<summary>SQL code to create table `dateel.t_series_ser`</summary>

``` {.sql include="../SQL/metric_40_datbast_t_series_ser.sql"}
```

</details>




### Import t_series_ser from trutta database

```{r refeel.t_series_ser_import_trutta}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import to to refeel.tr_series_ser

ser <- readxl::read_xlsx(file.path(datawd,
                                   "WGBAST_TRS_densities2024filled.xlsx"), sheet = "dane")
ser <- janitor::clean_names(ser)
ser <- ser[,1:9]
# res <- dbGetQuery(con_diaspara, "SELECT * FROM datbast.t_series_ser")
# clipr::write_clip(colnames(res))
riv <- dbGetQuery(con_diaspara_admin,
                  "SELECT are_code, riv_rivername  FROM refbast.tr_rivernames_riv 
                  JOIN refbast.tr_area_are on are_code = riv_are_code")
riv$riv = stringi::stri_trans_general(riv$riv_rivername, "latin-ascii")
ser$riv <-  stringi::stri_trans_general(ser$river, "latin-ascii")
ser <- ser |> inner_join(riv, by= join_by(riv))
# 584 on 10303 => 604 with stringi
# Need to add electrofishing types to gear
save(ser, file = "data/ser_wgbast.Rdata")
t_series_ser <-
  data.frame(
    "ser_id" = uuid::UUIDgenerate(n=nrow(ser)),
    "ser_code" = paste0(ser$country, "_", 
                        substr(stringi::stri_trans_general(ser$river, "latin-ascii"),1,4),"_P_TRS"),
    "ser_name"  = ser$river,
    "ser_spe_code" = "TRS",
    "ser_lfs_code" = "P",
    "ser_are_code" = ser$are_code,
    "ser_wkg_code" = "WGBAST",
    "ser_ver_code" = "WGBAST-2025-1",
    "ser_cou_code" = ser$country,
    "ser_hab_code" = NA, # TODO integrate habitats from eiunis https://eunis.eea.europa.eu/habitats-code-browser.jsp?expand=58,66,79,17#level_17
    "ser_gea_code" = '10.4', # electric fishing
    "ser_fiw_code" = NA,
    "ser_mon_code" = NA,
    "ser_uni_code" = "nr",
    "ser_effort_uni_code" = "nr/m2",
    "ser_description" = NA,
    "ser_locationdescription" = 
      paste0("main_river"=ser$main_river,", river = ",ser$river,",
     sub_div= ",ser$sub_div),
    "ser_wltyp_code" =  "FW",
    "ser_stocking" = NA,
    "ser_stockingcomment" = NA,
    "ser_protocol" = NA,
    "ser_samplingstrategy" = NA,
    "ser_datarightsholder" = NA,
    "ser_datelastupdate" = '2025-06-09' #,
    # geom
  )

res <- dbWriteTable(con_diaspara_admin, "t_series_ser_temp", 
                    t_series_ser, overwrite = TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM  datbast.t_series_ser;")
dbExecute(con_diaspara_admin, "INSERT INTO datbast.t_series_ser 
SELECT distinct on (ser_code)
 ser_id::uuid,
 ser_code,
 ser_name,
 ser_spe_code,
 ser_lfs_code,
 ser_are_code::TEXT,
 ser_wkg_code,
 ser_ver_code,
 ser_cou_code,
 ser_hab_code,
 ser_gea_code,
 ser_fiw_code,
 ser_mon_code,
 ser_uni_code,
 ser_effort_uni_code,
 ser_description,
 ser_locationdescription,
 ser_wltyp_code,
 ser_stocking,
 ser_stockingcomment,
 ser_protocol,
 ser_samplingstrategy,
 ser_datarightsholder,
 ser_datelastupdate::date
FROM t_series_ser_temp") # 25 



```

The table t_series_ser contains an extract of the series. Only a few were joined when trying
to match the names. A data integration using the habitat referential would allow to 
integrate at sub basin level though maybe a table of subbasins (with geometries) would need to 
be created.

```{r}
#| label: tbl-datbast.t_series_ser
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show series table for wbast (this is just an example).
#| tbl-cap: Table t_series_ser for series first 20 lines
dbGetQuery(con_diaspara, "SELECT * FROM datbast.t_series_ser limit 20;")|> 
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Creating table joining series and station

The table is created but empty. We need the stations in ICES first.

<details>

<summary>SQL code to create table `datbast.tj_seriesstation_ses`</summary>

``` {.sql include="../SQL/metric_41_datbast.tj_seriesstation_ses.sql"}
```

</details>


## Creating inherited table for annual series


<details>

<summary>SQL code to create tables `datbast.t_serannual_san`</summary>

``` {.sql include="../SQL/metric_43_datbast_t_serannual_san.sql"}
```

</details>


## Import data for annual series 

Data are imported from the electrofishing trutta db to `datbast.t_serannual_ser`.
Data are structured not by stage but by age group.


```{r datbast.t_serannual_ser}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import to datbast.t_serannual_ser

# start over from ser, previous chunk
load(file = "data/ser_wgbast.Rdata") #ser

ser0 <- dbGetQuery(con_diaspara_admin, "SELECT * FROM datbast.t_series_ser")
ser <- ser |> mutate(ser_code =  
                       paste0(ser$country, "_", substr(
                         stringi::stri_trans_general(ser$river, "latin-ascii"),1,4),"_P_TRS")) |>
  inner_join(ser0)

t_serannual_san_temp <-
  data.frame(
    "san_ser_id" = ser$ser_id,
    "san_id" = seq(along.with= ser$ser_id),
    "san_value"=ser$density_n_100m2,
    "san_year" = ser$year,
    "san_comment" = NA,
    "san_effort" = ser$number_of_sites,
    "san_datelastupdate" = Sys.Date(),
    "san_qal_id" = 1,
    "san_qal_comment" = NA,
    "san_wkg_code" = "WGBAST",
    "san_ver_code" = "WGBAST-2025-1",
    "san_agegroup" = ifelse(is.na(ser$age),"all",ser$age))


dbWriteTable(con_diaspara_admin, "t_serannual_san_temp", 
             t_serannual_san_temp, overwrite = TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM  datbast.t_serannual_san;")
dbExecute(con_diaspara_admin, "INSERT INTO datbast.t_serannual_san 
SELECT 
    san_ser_id::uuid,
    san_id,
    san_value,
    san_year,
    san_comment,
    san_effort,
    san_datelastupdate,
    san_qal_id,
    san_qal_comment,
    san_wkg_code,
    san_ver_code,
    san_agegroup
FROM t_serannual_san_temp") # 604

``` 

:::{.callout-note appearance="simple"}
## Note for age
Here age needs to be part of a constraint, values are 0+, >0+ but all is necessary
to replace NULL.
:::

```{r}
#| label: tbl-datbast.t_serannual_san
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show series table.
#| tbl-cap: Table databast.t_serannual_san for annual values  first 20 lines
dbGetQuery(con_diaspara, "SELECT * FROM datbast.t_serannual_san limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

# WGNAS

Here we import files from WP2


## series table t_series_ser


### Creating inherited series


<details>

<summary>SQL code to create table `datnas.t_series_ser`</summary>

``` {.sql include="../SQL/metric_50_datnas_t_series_ser.sql"}
```

</details>




### Import t_series_ser example data (WP2)

```{r refnas.t_series_ser}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import to to refnas.tr_series_ser

ser <- readxl::read_xlsx(file.path(datawd,
"../wgnas/burishoole.xlsx"),
sheet = "sampling_info",
col_types = c(rep("text",4),"numeric", rep("text", 8), rep("numeric", 2), "text")
)
# note I have manually added sai_x and sai_y to sampling_info
# below I'm getting the river code with a spatial query
ser <- ser[1:2,] 
ser <- st_as_sf(ser, coords = c("sai_x", "sai_y"), crs = 4326, remove = FALSE)

st_write(ser, con_diaspara, "series_temp")

temp = dbGetQuery(con_diaspara,
"SELECT * FROM series_temp join refnas.tr_area_are on 
          st_intersects(geometry, geom_polygon) WHERE
          are_lev_code = 'River'")$are_code

# Here check that we don't return two intersects or none (which might happen)

stopifnot(nrow(temp) == nrow(ser))
if (any(is.na(temp$are_code))) stop ("problem with projection, check location")


ser$are_code <- temp$are_code

# this was to get the name of the lfs code for name, I'm ignoring it currently
# stage = dbGetQuery(con_diaspara,
# "SELECT * FROM ref.tr_lifestage_lfs where lfs_spe_code = '127186'")

# ser$sai_lfs_code[ser$sai_lfs_code == 'S'] <- 'A'
# ser <- ser |> st_drop_geometry() |> left_join(stage|> select(lfs_code,lfs_name),
#  by = join_by(sai_lfs_code==lfs_code))

# create verion for diaspara
dbExecute(con_diaspara, "INSERT INTO refnas.tr_version_ver (ver_code,ver_year,ver_spe_code,ver_version,ver_description,ver_wkg_code)
	VALUES (
 'DIASPARA-2025-1',
 2025,
 'Salmo salar',
 1,
'WP2 data call for diaspara on LHT',
'WGNAS');"
)


# Need to add electrofishing types to gear
save(ser, file = "data/ser_burishoole.Rdata")
t_series_ser <-
data.frame(
"ser_id" = uuid::UUIDgenerate(n=nrow(ser)),
"ser_code" = ser$sai_name,
"ser_name"  = ser$sai_name,
"ser_spe_code" = "127186",
"ser_lfs_code" = ser$sai_lfs_code,
"ser_are_code" = ser$are_code, # got from spatial query
"ser_wkg_code" = "WGNAS",
"ser_ver_code" = "DIASPARA-2025-1",
"ser_cou_code" = ser$sai_cou_code,
"ser_hab_code" = NA, # TODO remove 
"ser_gea_code" = NA, # not used only monitoring
"ser_fiw_code" = NA,
"ser_mon_code" = "TR", -- both traps are TR, no fishway
"ser_uni_code" = "nr",
"ser_effort_uni_code" = NA,
"ser_description" = NA,
"ser_locationdescription" = NA, # TODO remove
"ser_wltyp_code" =  case_when(ser$sai_hty_code == "T" ~ "T",
ser$sai_hty_code == "C" ~ "MC",
ser$sai_hty_code == "F" ~ "FW",
ser$sai_hty_code == "MO" ~ "MO"),
"ser_stocking" = ser$"sai_riverorigin(0=reared,1=wild,2=mixed)" %in% c(0,2),
"ser_stockingcomment" = NA,
"ser_protocol" = ser$sai_protocol,
"ser_samplingstrategy" = ser$sai_samplingstrategy,
"ser_datarightsholder" = NA,
"ser_datelastupdate" = Sys.Date() #,
# geom
)

res <- dbWriteTable(con_diaspara, "t_series_ser_temp", 
t_series_ser, overwrite = TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM  datnas.t_series_ser;")
dbExecute(con_diaspara_admin, "INSERT INTO datnas.t_series_ser 
SELECT distinct on (ser_code)
 ser_id::uuid,
 ser_code,
 ser_name,
 ser_spe_code,
 ser_lfs_code,
 ser_are_code::TEXT,
 ser_wkg_code,
 ser_ver_code,
 ser_cou_code,
 ser_hab_code,
 ser_gea_code,
 ser_fiw_code,
 ser_mon_code,
 ser_uni_code,
 ser_effort_uni_code,
 ser_description,
 ser_locationdescription,
 ser_wltyp_code,
 ser_stocking,
 ser_stockingcomment,
 ser_protocol,
 ser_samplingstrategy,
 ser_datarightsholder,
 ser_datelastupdate::date
FROM t_series_ser_temp") # 2



```

::: {.callout-note appearance="simple"}

## Notes to Viktor (WP2) :

Some of the columns (location, location description, protocol) will be removed 
from the exchange format currently developped with ICES as they cannot be standardized,
I'm keeping them
here while importing but in the future they will be in reports describing all the
series and attached to DOI.

For lifestages `S` spawner is `A` Adult 

The code of the area is the river.

:::


::: {.callout-caution appearance="simple"}

## TODO

Create Geom for x and Y

:::


```{r}
#| label: tbl-datnas.t_series_ser
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show series table (burishoole example).
#| tbl-cap: Table datnas.t_series_ser first 20 lines
dbGetQuery(con_diaspara, "SELECT * FROM datnas.t_series_ser limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

### Import t_seriesannual_san

<details>

<summary> SQL code to create table `datnas.tj_seriesstation_ses`
</summary>

``` {.sql include="../SQL/metric_51_datnas.tj_seriesstation_ses.sql"}
```

</details>


## Creating inherited table for annual series


<details>

<summary>SQL code to create tables `datnas.t_serannual_san`</summary>

``` {.sql include="../SQL/metric_52_datnas_t_serannual_san.sql"}
```

</details>

::: {.callout-note appearance="simple"}

## Notes 

Currently there is no annual series in WP2 only group and individual metrics,
 the the table is created but no import is done.

:::



# Creating group metrics

## Create group table

:::{.callout-caution appearance="simple"}
## Note for group metrics
Need a foreign key on both species and lfs code.
:::


## Create group table for datnas

<details>

<summary>SQL code to create table `datnas.t_group_gr`</summary>

``` {.sql include="../SQL/metric_53_datnas_t_group_gr.sql"}
```

</details>

## Import data for group


:::{.callout-caution appearance="simple"}
## Group metrics
There are no group metrics currently
:::


<details>

<summary>SQL code to create table `datnas.t_group_gr`</summary>

``` {.sql include="../SQL/metric_54_datnas_t_grouptrait_grt.sql"}
```

</details>


# Creating ind metrics 



<details>

<summary>SQL code to import data tables</summary>

``` {.sql include="../SQL/metric_55_datnas_t_fish_fi.sql"}
```

</details>


```{r}
#| label: tbl-datnas.t_fish_fi
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show fish table.
#| tbl-cap: Table t_fish_fi, fish table
dbGetQuery(con_diaspara, "SELECT * FROM datnas.t_fish_fi limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```


## Referential for numeric traits (refnas.tr_traitnumeric_trn)

<details>

<summary>SQL code to create table  `refnas.tr_traitnumeric_trn` </summary>

``` {.sql include="../SQL/metric_56_refnas_tr_traitnumeric_trn.sql"}
```

</details>



```{r}
#| label: refnas_tr_traitnumeric_trn_insert
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import numeric trait.

#tra <- dbGetQuery(con_diaspara, "SELECT * FROM ref.tr_traitnumeric_trn;")
# we will include group metric names later
# tra <- tra[tra$tra_id %in% c(1,2),]
# tra$tra_wkg_code <- "WGNAS"
# tra$tra_spe_code = "127186"


# df_to_tribble_code <- function(df) {
#   stopifnot(requireNamespace("tibble", quietly = TRUE))
  
  
#   cols <- names(df)
#   header <- paste0("tibble::tribble(\n  ~", paste(cols, collapse = ", ~"), ",\n")
  
#   row_lines <- apply(df, 1, function(row) {
#     vals <- Map(function(val) {
#       if (is.character(val)) {
#         dquote(val)
#       } else if (is.factor(val)) {
#         sprintf("%s", as.character(val))
#       } else if (is.logical(val)) {
#         ifelse(is.na(val), "NA", ifelse(val, "TRUE", "FALSE"))
#       } else if (is.numeric(val)) {
#         ifelse(is.na(val), "NA_real_", as.character(val))
#       } else if (inherits(val, "Date")) {
#         sprintf("as.Date("%s")", format(val, "%Y-%m-%d"))
#       } else if (inherits(val, "POSIXt")) {
#         sprintf("as.POSIXct("%s", tz = "%s")",
#                 format(val, "%Y-%m-%d %H:%M:%S"),
#                 attr(val, "tzone") %||% "UTC")
#       } else if (is.na(val)) {
#         "NA"
#       } else {
#         # Fallback to dput for unsupported types in a cell
#         paste(capture.output(dput(val)), collapse = "")
#       }
#     }, row)
#     paste0("  ", paste(vals, collapse = ", "), ",")
#   })
  
#   body <- paste(row_lines, collapse = "\n")
#   paste0(header, body, "\n)")
# }

# # Example
# library(tibble)
# df_to_tribble_code(tra)

tranum <- tibble::tribble(
  ~tra_id, ~tra_code, ~tra_description, ~tra_wkg_code, 
  ~tra_spe_code,  ~tra_typemetric, ~tra_qualitativeornumeric,
  ~trn_uni_code, ~trn_minvalue, ~trn_maxvalue,
  1, "Length_mm", 
  "Total body length in millimeters (mm) or mean total body length for group", 
  "WGNAS", "127186", "Both", "Numeric",
  "mm", NA, NA,
  2, "Weightg", "Weight (g) or mean weight for group", "WGNAS", 
  "127186", "Both", "Numeric",
  "g", NA, NA,
  3, "FreshwaterAge_year", 
  "Age at capture for juveniles or smolt age for adults in years. An individual aged in the same year as birth is 0.", 
  "WGNAS", "127186", "Both", "Numeric",
  "nr year", NA, NA,
  4, "SeaAge_year", 
  "Sea age at capture in years. Leave blank for juveniles.  An individual aged in the same year as its transition to salt water is 0", 
  "WGNAS", "127186", "Both", "Numeric", 
  "nr year", NA, NA,
  5, 
  "TotAge_year", 
  "Sea age at capture in years. Leave blank for juveniles. An individual aged in the same year as its transition to salt water is 0", 
  "WGNAS", "127186", "Both", "Numeric", 
  "nr year", NA, NA,  
  6, "ScalRad_mm", 
  "Scale reading radius in mm, if used provide a code for the ScalAnnCode method", 
  "WGNAS", "127186", "Individual", "Numeric", 
  "mm", NA, NA,  
  7, "Fec_negg", 
  "Fecundity in number of eggs", 
  "WGNAS", "127186", "Both", "Numeric",
   "nr", NA, NA,
  8, "Fec_uncertainty_sd",
  "Uncertainty in fecundity resulting from measures of egg samples. Standard deviation", 
  "WGNAS", "127186", "Both", "Numeric",
  "nr", NA, NA,
  9, "FemaleProportion", 
  "Proportion of female (in numbers) between 0 (all males) and 1 (all females).", 
  "WGNAS", "127186", "Group", "Numeric",
  )

tranum$trn_minvalue <- as.numeric(tranum$trn_minvalue)
tranum$trn_maxvalue <- as.numeric(tranum$trn_maxvalue)
dbWriteTable(con_diaspara_admin, "tr_traitnumeric_trn_temp", tranum, overwrite =TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM refnas.tr_traitnumeric_trn")
dbExecute(con_diaspara_admin, "INSERT INTO refnas.tr_traitnumeric_trn(
tra_id,
tra_code,
tra_wkg_code,
tra_spe_code,
tra_description,
tra_typemetric,
trn_uni_code,
tra_qualitativeornumeric,
trn_minvalue,
trn_maxvalue)
SELECT 
tra_id,
tra_code,
tra_wkg_code,
tra_spe_code,
tra_description,
tra_typemetric,
trn_uni_code,
tra_qualitativeornumeric,
trn_minvalue::numeric,
trn_maxvalue::numeric
 FROM tr_traitnumeric_trn_temp") #8


```


```{r}
#| label: tbl-refnas.tr_traitnumeric_trn
#| echo: FALSE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show trait numeric table.
#| tbl-cap: Quantitative parameters parameters
dbGetQuery(con_diaspara, "SELECT * FROM refnas.tr_traitnumeric_trn;") |>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```

:::{.callout-caution}
## Question for Viktor (WP2) ?
There is a method for winter measurement reading but no column to put the corresponding
data ? I'm not sure I understand. Do you have something you used ? 
Should it be a vector ?
:::


:::{.callout-caution}
## Question for Viktor (WP2) ?
Can you provide bounds for numeric values in the code above ?
:::

:::{.callout-note}
## Note Viktor (WP2) 
Currently you have two columns one juvenile_age which can be Smolt or juvenile age.
And then in group metrics you have smolt age. 
I find it confusing. I'm proposing to call it a freshwater age.
Currently in the database the stage should never be null, so if it's a parr 
or a smolt the meaning would be different. Freshwater age for a smolt or and
adult is the smolt age.
:::



## Referential for qualitative traits (refnas.tr_traitqualitative_trq)

<details>

<summary>SQL code to create table  `refnas.tr_traitqualitative_trq` </summary>

``` {.sql include="../SQL/metric_57_refnas_tr_traitqualitative_trq.sql"}
```

</details>


```{r}
#| label: refnas_tr_tr_traitqualitative_trq_insert
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import qualitative trait.

traqal <- tibble::tribble(
  ~tra_id, ~tra_code, ~tra_description, ~tra_wkg_code, 
  ~tra_spe_code,  ~tra_typemetric, ~tra_qualitativeornumeric,
  1, "Sex", 
  "Sex (F Female,H Hermaphordite, I Immature attempt made, M Male, T Transitional, U Undetermined no attempt made, X Mixed)", 
  "WGNAS", "127186", "Individual", "Qualitative",

  2, "AdiposeFinPresence", "Presence of adipose fin (0 = absent (reared), 1=present (wild))", "WGNAS", 
  "127186", "Individual", "Numeric"    
  )


dbWriteTable(con_diaspara_admin, "tr_traitqualitative_trq_temp", traqal, overwrite =TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM refnas.tr_traitqualitative_trq")
dbExecute(con_diaspara_admin, "INSERT INTO refnas.tr_traitqualitative_trq(
tra_id,
tra_code,
tra_wkg_code,
tra_spe_code,
tra_description,
tra_typemetric,
tra_qualitativeornumeric
)
SELECT 
tra_id,
tra_code,
tra_wkg_code,
tra_spe_code,
tra_description,
tra_typemetric,
tra_qualitativeornumeric
 FROM tr_traitqualitative_trq_temp") #2

```


```{r}
#| label: tbl-refnas.tr_traitqualitative_trq
#| echo: FALSE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show trait numeric table.
#| tbl-cap: Quantitative parameters parameters
dbGetQuery(con_diaspara, "SELECT * FROM refnas.tr_traitqualitative_trq;") |>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```

## Values of Qualitative fish trait (tr_traitvaluequal_trv)



<details>

<summary>SQL code to create tables `ref.tr_traitqualvalue_trv` and `refeel.tr_traitqualvalue_trv`</summary>

``` {.sql include="../SQL/metric_57_ref_tr_traitvaluequal_trv.sql"}
```
</details>



```{r tbl-refnas_tr_traitqualitative_trq}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import trait values for qualitative parm.
#| tbl-cap: Table of possible qualitative trait values

#trve <- dbGetQuery(con_diaspara, "SELECT * FROM ref.tr_traitvaluequal_trv;")
trqn <- dbGetQuery(con_diaspara, "SELECT * FROM refnas.tr_traitqualitative_trq;")
#clipr::write_clip(colnames(trv))
trv <-  data.frame(
  "trv_id"=1:12,
  "trv_trq_code"=c(
    rep(trqn$tra_code[1],7),
    rep(trqn$tra_code[2],5)
    ),
  "trv_code"=c(
    c("F","I","M","T","U","X","H"), 
    c("Y","N","P","NA","U")
    ),
  "trv_description" = c(
    c("Female",
    "Immature - attempt made but sex could not be destinguished",
  "Male",
  "Transitional", 
  "Undetermined - no attempt made",
  "Mixed",
  "Hermaphrodite"
  ),
  c("Yes","No", "Probable","Not Applicable", "Unknown")
  ),
  "trv_spe_code" = "127186",
  "trv_wkg_code" = "WGNAS"
)
dbWriteTable(con_diaspara_admin, "tr_traitvaluequal_trv_temp", trv,
             overwrite =TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM refnas.tr_traitvaluequal_trv");
dbExecute(con_diaspara_admin, "INSERT INTO refnas.tr_traitvaluequal_trv (
trv_id,
trv_trq_code,
trv_code,
trv_description,
trv_spe_code,
trv_wkg_code)
SELECT 
trv_id,
trv_trq_code,
trv_code,
trv_description,
trv_spe_code,
trv_wkg_code
 FROM tr_traitvaluequal_trv_temp;") #12

```

```{r}
#| label: tbl-refnas_tr_traitvalueqal_trv
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show trait value table.
#| tbl-cap: Values for qualitative parameters
dbGetQuery(con_diaspara, "SELECT * FROM refnas.tr_traitvaluequal_trv;") |>
  knitr::kable() |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

```



## Referential for trait methods (refnas.tr_traitmethod_trm)



<details>

<summary>SQL code to create table  `refnas.tr_traitmethod_trm` </summary>

``` {.sql include="../SQL/metric_59_refnas_tr_traitmethod_trm.sql"}
```

</details>

```{r refnas_tr_traitmethod_trm_insert}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import trait method.

trm <- tibble::tribble(
  ~trm_id, ~trm_code, ~trm_description, ~trm_wkg_code, 
  ~trm_spe_code,
  1, "GonadalInspection", 
  "Sex (F Female,H Hermaphordite, I Immature attempt made, M Male, T Transitional, U Undetermined no attempt made, X Mixed)", 
  "WGNAS", "127186", "Individual", "Qualitative",

  2, "PresenceAdiposeFin", "Presence of adipose fin (0 = absent (reared), 1=present (wild))", "WGNAS", 
  "127186", "Individual", "Numeric"    
  )

  6, 
  "ScalAnnCode", 
  "Scale reading annulus code for identifying the type of the corresponding scale radius measurement:
   0 means that the measurement corresponds to an annulus of the fish, 
   1 means salt water check (freshwater to saltwater transition) 
   and 2 means that the radius is a measurement from the center to the edge of the scale (radius at capture)", 
  "WGNAS", "127186", "Both", "Numeric", 

```


## Table t_indtrait_int

<details>

<summary>SQL code to create table  `datnas.t_indivtrait_int` </summary>

``` {.sql include="../SQL/metric_60_datnas_t_indivtrait_int.sql"}
```

</details>

```{r refnas.t_indmetrics_ind}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import to to refnas.t_indivtrait_int

ind <- readxl::read_xlsx(file.path(datawd,
"../wgnas/burishoole.xlsx"),
sheet = "new_individual_metrics",
col_types = c("text", "text", rep("date",2),"numeric", "text", rep("numeric",2),
 rep("text", 2), rep("numeric",8), "text", rep("numeric",3), 
 "text", rep("numeric",2), rep("text", 2))
) 
ind <- janitor::clean_names(ind)




st_write(ind, con_diaspara, "temp_ind")

temp = dbGetQuery(con_diaspara,
"SELECT * FROM temp_ind join datnas.t_series_ser on ser_code = sai_name")

stopifnot(nrow(ind)==nrow(temp))


# fi <- dbGetQuery(con_diaspara, 
# "SELECT * FROM datnas.t_fish_fi")
# paste(colnames(fi), collapse= ", ")
fi <- data.frame(
fi_ser_id =temp$ser_id, 
fi_wkg_code = temp$ser_wkg_code, 
fi_spe_code = temp$ser_spe_code, 
fi_lfs_code = case_when(temp$fi_lfs_code == "S" ~ "A",
is.na(temp$fi_lfs_code) ~ "SM"),
fi_date = temp$fi_datecapture, 
 fi_year = year(temp$fi_datecapture), 
 fi_comment = temp$fi_comment, 
 fi_lastupdate = today(), 
 fi_idsource = temp$fi_id_cou, 
 fi_ver_code = "DIASPARA-2025-1",
 fi_x_4326 = temp$fisa_x_4326, 
 fi_y_4326 = temp$fisa_y_4326)


dbWriteTable(con_diaspara,  "temp_fi", fi, overwrite =TRUE)

# create verion for diaspara
dbExecute(con_diaspara_admin, "INSERT INTO datnas.t_fish_fi (
fi_ser_id, fi_wkg_code, fi_spe_code, fi_lfs_code, fi_date, fi_year, 
fi_comment, fi_lastupdate, fi_idsource, fi_ver_code, fi_x_4326, fi_y_4326)
SELECT 
fi_ser_id::uuid, fi_wkg_code, fi_spe_code, fi_lfs_code, fi_date, fi_year, 
fi_comment, fi_lastupdate, fi_idsource, fi_ver_code, fi_x_4326, fi_y_4326 
from temp_fi")	# 2965

# process fi_geom

dbExecute(con_diaspara_admin, "UPDATE datnas.t_fish_fi set fi_geom = 
ST_SetSRID(ST_MakePoint(fi_x_4326, fi_y_4326),4326)") # 2965

t_series_ser <-
data.frame(
"ser_id" = uuid::UUIDgenerate(n=nrow(ser)),
"ser_code" = ser$sai_name,
"ser_name"  = ser$sai_name,
"ser_spe_code" = "127186",
"ser_lfs_code" = ser$sai_lfs_code,
"ser_are_code" = ser$are_code, # got from spatial query
"ser_wkg_code" = "WGNAS",
"ser_ver_code" = "DIASPARA-2025-1",
"ser_cou_code" = ser$sai_cou_code,
"ser_hab_code" = NA, # TODO remove 
"ser_gea_code" = NA, # electric fishing
"ser_fiw_code" = NA,
"ser_mon_code" = NA,
"ser_uni_code" = "nr",
"ser_effort_uni_code" = NA,
"ser_description" = NA,
"ser_locationdescription" = NA, # TODO remove
"ser_wltyp_code" =  case_when(ser$sai_hty_code == "T" ~ "T",
ser$sai_hty_code == "C" ~ "MC",
ser$sai_hty_code == "F" ~ "FW",
ser$sai_hty_code == "MO" ~ "MO"),
"ser_stocking" = ser$"sai_riverorigin(0=reared,1=wild,2=mixed)" %in% c(0,2),
"ser_stockingcomment" = NA,
"ser_protocol" = ser$sai_protocol,
"ser_samplingstrategy" = ser$sai_samplingstrategy,
"ser_datarightsholder" = NA,
"ser_datelastupdate" = Sys.Date() #,
# geom
)

res <- dbWriteTable(con_diaspara, "t_series_ser_temp", 
t_series_ser, overwrite = TRUE)
dbExecute(con_diaspara_admin, "DELETE FROM  datnas.t_series_ser;")
dbExecute(con_diaspara_admin, "INSERT INTO datnas.t_series_ser 
SELECT distinct on (ser_code)
 ser_id::uuid,
 ser_code,
 ser_name,
 ser_spe_code,
 ser_lfs_code,
 ser_are_code::TEXT,
 ser_wkg_code,
 ser_ver_code,
 ser_cou_code,
 ser_hab_code,
 ser_gea_code,
 ser_fiw_code,
 ser_mon_code,
 ser_uni_code,
 ser_effort_uni_code,
 ser_description,
 ser_locationdescription,
 ser_wltyp_code,
 ser_stocking,
 ser_stockingcomment,
 ser_protocol,
 ser_samplingstrategy,
 ser_datarightsholder,
 ser_datelastupdate::date
FROM t_series_ser_temp") # 2



```

::: {.callout-note appearance="simple"}

## Notes to Viktor (WP2) :

In the template there is a fi_daterelease. It's empty. Are you sure we need this ?

:::

::: {.callout-note appearance="simple"}

## Notes to Viktor (WP2) :

In the template there is a fi_tagnumber. 
Do you think the international database is
the place to hold information about the tag. 
Or should it be handled at the national level ?

:::


```{r}
#| label: tbl-datnas.t_indivtrait_int
#| echo: FALSE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to show fish table.
#| tbl-cap: Table t_indivtrait_int, fish metric table
dbGetQuery(con_diaspara, "SELECT * FROM datnas.t_indivtrait_int limit 20;")|>
  knitr::kable()|>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```


# Acknowledgements

Maria and Joana for their help.
Rui and Carlos for their support.

