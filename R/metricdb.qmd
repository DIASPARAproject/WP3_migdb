---
title: "diaspara metric database creation script"
subtitle: "DIASPARA WP3.2 working document"
author: "Briand CÃ©dric, Oliviero Jules, Helminen Jani"
date: last-modified
date-format: "DD-MM-YYYY"
description: "Creation of metric db, version = build"
title-block-banner: "images/diaspara_bandeau.png"
title-block-banner-color: "white"
format:
 html:
  self-contained: true
  theme: styles.scss
  smooth-scroll: true
  fontcolor: black
  toc: true
  toc-location: left
  toc-title: Summary
  toc-depth: 3
execute: 
 keep-md: true
filters:
  - include-code-files
reference-location: document
bibliography: diaspara.bib
include-after-body: "footer.html"
---

Aside the main db report, which describes all the vocabularies used in this document, we have to build a separate database for metrics. In the project these correspond to LHT, but it's more, the data should also correspond to the time series and the sampling db developped by WGEEL. The two latter data structure (series and sampling) are very similar and they both hold very similar group metrics and individual metrics.

 The first was developed initially to store data about the series used in recruitment. In practice, it consists of three tables, the `t_series_ser` (Figure @fig-series_diagram_wgeel - top in blue) table contains series id and description, with columns describing the sampling details, the stage used, the method... This is the main identifier of the series which will be used as a reference in all dependent tables. The second `t_dataseries_das` table  (Figure @fig-series_diagram_wgeel - on the right) holds data about annual values in series. These are typically annual counts for recruitment, along with additional effort data. Linked to these are group metric series used to describe the series, mean age of eel, mean size, proportion of glass eel among the yellow eels, proportion of females ... (Figure @fig-series_diagram_wgeel - in orange)
Finally, we can link individual metrics. The individual metrics are all detailed for one fish. And they concern metrics like size, weight, sex, but also can hold data about quality, contamination. So these are in essence the Life History traits analysed by WP2 in DIASPARA  (Figure @fig-series_diagram_wgeel - in pink).

![Diagram for series](images/series_diagram_wgeel.png "A sql diagram of the relations of tables for series"){#fig-series_diagram_wgeel}

The second type of data was developed to hold the data collected for DCF. These can be metrics collected from sampling by the fishermen, data coming from the analysis of electrofishing data, or other experimental sampling that are not reported as series. Currently the two structures for series and sampling are very close, the only difference is that there is no annual number linked to the sampling data, and that they are not linked to a stage in the first table, so the stage is added in the fish table.
The difference in table structure is illustrated below in tables highlighted in yellow (Figure @fig-sampling_diagram_wgeel).

![Diagram for sampling](images/sampling_diagram_wgeel.png "A sql diagram of the relations of tables for sampling"){#fig-sampling_diagram_wgeel}

The database development highlighted in the current report has several objectives :

* The first objective is to join the two database to simplify the database development and handling of data.

* The second objective is to use the new referentials created for the migdb database.

* The third objective is to import data from WP2, the excel sheets have been created in february 2025 and will already (in March) require some adaptation as the database evolves, for instance the referential of stages is no longer in line with the templates.

* The fourth objective is to hand over this database, along with the migdb to ICES, for integration in ICES database ecosystem, and use of DATSU in datacall.

* The fifth objective is to adapt the shiny scripts of data integration.

# Creating the database structure from WGEEL (TODO)


[git issue #23 Write simplified structure from WGEEL](https://github.com/DIASPARAproject/WP3_migdb/issues/23)

The main issue will require to merge the two table structures (sampling and series) and adapt to migdb vocabulary.

Once done a beta version probably not completely adapted will be released.

[milestone metric DB beta version](https://github.com/DIASPARAproject/WP3_migdb/milestone/6)


```{r init}
#| echo: FALSE
#| warning: FALSE
#| message: FALSE
#| results: 'hide'

#if (!grepl("montepomi", getwd())) {
if(Sys.info()[["user"]] == 'joliviero'){
setwd("D:/workspace/DIASPARA_WP3_migdb/R")
datawd <- "D:/DIASPARA/wgbast"
} else if (Sys.info()[["user"]] == 'cedric.briand'){
setwd("C:/workspace/DIASPARA_WP3_migdb/R")
datawd <- "C:/Users/cedric.briand/OneDrive - EPTB Vilaine/Projets/DIASPARA/wgbast"
}
source("utilities/load_library.R")
load_library("tidyverse")
load_library("knitr")
load_library("kableExtra")
load_library("icesVocab")
load_library("readxl")
load_library("janitor")
load_library("skimr")
load_library("RPostgres")
load_library("yaml")
load_library("DBI")
load_library("ggplot2")
load_library("sf")
load_library("janitor") # clean_names
cred <- read_yaml("../credentials.yml")
cred <- read_yaml("../credentials.yml")
con_diaspara <- dbConnect(Postgres(), 
                           dbname = cred$dbnamediaspara,
                           host = cred$host,
                           port = cred$port,
                           user = cred$userdiaspara,
                           password = cred$passworddiaspara)
con_diaspara_admin <- dbConnect(Postgres(), 
                           dbname = cred$dbnamediaspara,
                           host = cred$host,
                           port = cred$port,
                           user = cred$usersalmo,
                           password = cred$passwordsalmo)
con_salmoglob <- dbConnect(Postgres(), 
                           dbname = cred$dbnamesalmo,
                           host = cred$host,
                           port = cred$port,
                           user = cred$usersalmo,
                           password = cred$passwordsalmo)




```
## Station

To include the station, we need two tables, the fist one is the Station dictionary
and the second is the relation Dictionary (which relates two stations together).

### SemanticRelation


```{r tbl-icesVocabRelation}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import relation.
#| tbl-cap: Semantic relation


SemanticRelation <- getCodeList("SemanticRelation")
knitr::kable(SemanticRelation) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
dbWriteTable(con_diaspara, "SemanticRelation", PRGOV)
dbExecute(con_diaspara, 'ALTER TABLE "SemanticRelation" SET SCHEMA ref;') 
  
```

### PRGOV
```{r tbl-icesPRGOV}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import PRGOV.
#| tbl-cap: Program Governance for the Station Dictionary


PRGOV <- getCodeList("PRGOV")
knitr::kable(PRGOV) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
dbWriteTable(con_diaspara, "PRGOV", PRGOV)
dbExecute(con_diaspara, 'ALTER TABLE "PRGOV" SET SCHEMA ref;') 
```

### EDMO

```{r tbl-icesEDMO}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import EDMO.
#| tbl-cap: European Directory of Marine Organisations (EDMO)


EDMO <- getCodeList("EDMO")
knitr::kable(EDMO) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
dbWriteTable(con_diaspara, "EDMO", EDMO)
dbExecute(con_diaspara, 'ALTER TABLE "EDMO" SET SCHEMA ref;')   
```

### PURPM

```{r tbl-icesPURPM}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import PURPM.
#| tbl-cap: Purpose of Monitoring


PURPM <- getCodeList("PURPM")
knitr::kable(PURPM) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
dbWriteTable(con_diaspara, "PURPM", PURPM)
dbExecute(con_diaspara, 'ALTER TABLE "PURPM" SET SCHEMA ref;')   
```

### DTYPE

```{r tbl-icesStation_DTYPE}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import icesStation_DTYPE.
#| tbl-cap: Station dictionary data type


Station_DTYPE <- getCodeList("Station_DTYPE")
knitr::kable(Station_DTYPE) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
dbWriteTable(con_diaspara, "Station_DTYPE", Station_DTYPE)
dbExecute(con_diaspara, 'ALTER TABLE "Station_DTYPE" SET SCHEMA ref;')   
```

### WLTYP

```{r tbl-icesStation_WLTYP}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import ices WLTYP.
#| tbl-cap: Water and Land Station Type


WLTYP <- getCodeList("WLTYP")
knitr::kable(WLTYP) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
dbWriteTable(con_diaspara, "WLTYP", WLTYP)
dbExecute(con_diaspara, 'ALTER TABLE "WLTYP" SET SCHEMA ref;')   
```

### MSTAT

```{r tbl-icesStation_MSTAT}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import ices MSTAT.
#| tbl-cap: Type of monitoring station


MSTAT <- getCodeList("MSTAT")
knitr::kable(MSTAT) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
dbWriteTable(con_diaspara, "MSTAT", MSTAT)
dbExecute(con_diaspara, 'ALTER TABLE "MSTAT" SET SCHEMA ref;')   
```


### Deprecated


```{r tbl-icesStation_Deprecated}
#| echo: TRUE
#| eval: FALSE
#| warning: FALSE
#| message: FALSE
#| code-fold: TRUE
#| code-summary: Code to import ices Deprecated.
#| tbl-cap: Deprecated


Deprecated <- getCodeList("Deprecated")
knitr::kable(Deprecated) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
dbWriteTable(con_diaspara, "Deprecated", Deprecated)
dbExecute(con_diaspara, 'ALTER TABLE "Deprecated" SET SCHEMA ref;')   
```


<details>

<summary>SQL code to create tables</summary>

``` {.sql include="../SQL/metric_01_create_StationDictionary.sql"}
```

</details>

## Creating series referential ref.ref_tr_seriesvocab_svc

Series are created in ref. It's a vocabulary.
They might be linked to a station (from the station vocabulary) but not in the vocab table, as we need a unique identifier here and a series will not always correspond to a location.
of an interannual sampling scheme for migratory fishes.
It will be created a an UUID (unique by construction) and a code also unique.

<details>

<summary>SQL code to create tables</summary>

``` {.sql include="../SQL/metric_00_create_ref_tr_seriesvocab_svc.sql"}
```

</details>

## Creating series main table dat.t_series_ser




<details>

<summary>SQL code to create tables</summary>

``` {.sql include="../SQL/metric_10_create_dat_t_series_ser.sql"}
```

</details>

This table is inherited so the table created in dat will be empty, and will
only receive data by inheritance. It can be considered as a view for ICES (no 
inheritance in SQL server).

Since this table is inherited the wkg needs to be included. One table will be created
per working group. These tables will be collated together.
Most details information about metadata will be in the metadata tables, either
to describe annual sampling or to describe individual metric collection.

Monitoring stations (including fixed stations) that are used for recurring sampling or data collection are managed via the Station Code Request Application in ICES [@ices_vocab_2024].
This table will reference monitoring station but it might be NULL, as some sampling 
designs or data collection, for instance for the DCF, are not related to a station.


:::::: questionbox
:::: questionbox-header
::: questionbox-icon
:::

QUESTION ICES (CÃ©dric via Teams meeting)
::::

::: questionbox-body
The ser_id might in some cases correspond to a fixed station but not only. For this reason 
the station is referenced here but another code will be created to reference the
sampling collection. Is this OK ?
:::
::::::


:::::: answerbox
:::: answerbox-header
::: answerbox-icon
:::

ANSWER ICES : Maria (20/05/2025)
::::

::: answerbox-body
Yes this makes sense,  I would advise 
to use both the stations and a unique identifier at the top. Using UUID will help
unicity there. It's not clear if it needs to 
be a vocabulary. 
There is a procedure to integrate stations, but for this we will probably do a bulk import.
:::
::::::








The detailed workflow on code requests from ICES can be viewed in the ICES Vocabularies and Codes data flow schematic, available in ICES publications.




# Import data from WGEEL (TODO)


If this works then the rest should follow smoothly
[git issue #25 Import data from WGEEL](https://github.com/DIASPARAproject/WP3_migdb/issues/23)

The release date for that one is :

[Milestone release alpha](https://github.com/DIASPARAproject/WP3_migdb/milestone/5)

So the metric release will be after wgeel, but hopefully some of the work will be started and this can be discussed during wgeel.

# Import data from WP2 (TODO)


# Adapt to ICES format (TODO)


# Import to ICES



# Acknowledgements

