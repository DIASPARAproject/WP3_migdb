---
title: "WGNAS database description"
subtitle: "DIASPARA WP3.2 working document"
author: "Briand CÃ©dric, Oliviero Jules, Helminen Jani"
date: last-modified
date-format: "DD-MM-YYYY"
description: "Technical analysis of the salmoglob database"
title-block-banner: "images/diaspara_bandeau.png"
title-block-banner-color: "white"
format:
 html:
  self-contained: true
  theme: cosmo
  smooth-scroll: true
  fontcolor: black
  toc: true
  toc-location: left
  toc-title: Summary
  toc-depth: 3
reference-location: document
bibliography: ../diaspara.bib
---


The following working document is just a technical analysis of the WGNAS database (and further its graphical interface) [@ices_second_2024]. It uses different sources, ICES vocabulary, the stock annex [@ICES2021_wgnas_stock_annex], to analyse the structure of the wgnas database before integrating in a single database (wgnas, wgbast, wgeel) in the DIASPARA project.
This document does not engage the WGNAS it's just a technical analysis, to try to get how this works.
This document is listed as a task there :
https://github.com/DIASPARAproject/WP3_migdb/issues/11


```{r init}
#| echo: FALSE
#| warning: FALSE
#| message: FALSE
#| results: 'hide'

#if (!grepl("montepomi", getwd())) {
if(Sys.info()[["user"]] == 'joliviero'){
setwd("D:/workspace/DIASPARA_WP3_migdb/R")
} else if (Sys.info()[["user"]] == 'cedric.briand'){
setwd("C:/workspace/DIASPARA_WP3_migdb/R")
}
source("utilities/load_library.R")
load_library("RPostgres")
load_library("sf")
load_library("getPass")
load_library("readxl")
load_library("flextable")
load_library("tidyverse")
load_library("yaml")
load_library("DBI")
load_library("knitr")
load_library("kableExtra")
cred=read_yaml("../credentials.yml")
con_salmoglob = dbConnect(Postgres(), dbname=cred$dbnamesalmo,host=cred$host,port=cred$port,user=cred$usersalmo, password=cred$passwordsalmo)
```

# Main database structure

```{r databasedescription}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| tbl-cap: 'Structure of the main database'
#| label: fig-maindb

database10 <- DBI::dbGetQuery(con_salmoglob, 'SELECT * FROM public.database limit 20')
knitr::kable(database10) %>% kable_styling(bootstrap_options = c("striped","hover", "condensed"))
```

# Area


![Phylogeographic structuring observed across studies in Atlantic salmon resolved by screening of phylogenetically informative nuclear microsatellite and SNP variation.](images/phylogeographic_structuring_salmon.png)
{#fig-phylogeographicstructures}


```{r area}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| tbl-cap: Area types
#| tbl-subcap: 
#|   - Fisheries
#|   - Countries
#|   - Source area
#| label: tbl-areatypes
area <- DBI::dbGetQuery(con_salmoglob, 'SELECT DISTINCT area FROM public.database')
knitr::kable(area[grep("fishery",area$area),,drop=FALSE], caption = "Area corresponding to fisheries", row.names=FALSE)
knitr::kable(area[grep("coun",area$area),,drop=FALSE], caption = "Area corresponding to countries", row.names=FALSE)
knitr::kable(area[!grepl("coun",area$area) & !grepl("fishery",area$area),,drop=FALSE], caption = "Area corresponding to source area", row.names=FALSE)
```

The latter table is by default, so Atlantic, NEC and NAC are included. Having a label in a reference table and a geom to associate to those labels would be I guess very usefull.

# Location


```{r location}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| tbl-cap: Locations
#| tbl-subcap: 
#|   - Fisheries
#|   - Weird
#|   - Areas
#| label: tbl-locations
location <- DBI::dbGetQuery(con_salmoglob, 'SELECT DISTINCT location FROM public.database')
knitr::kable(location[grep("fishe",tolower(location$location)),,drop=FALSE], caption = "Location corresponding to fisheries", row.names=FALSE)
location_biz <- data.frame("location"=setdiff(location[!grepl("fishe",tolower(location$location)),],
  area[!grepl("coun",area$area) & !grepl("fishery",area$area),]))
knitr::kable(location_biz, caption = "These one are neither fishery nor area, can we simplify at parameter level", row.names=FALSE)  
location_area <- data.frame("location"=intersect(location[!grepl("fishe",location$location),],
  area[!grepl("coun",area$area) & !grepl("fishery",area$area),]))
knitr::kable(location_area, caption = "Location corresponding exactly to what is aleardy in area", row.names=FALSE)
```


```{r param_biz}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
#| results: 'asis'
#| tbl-cap: List of parameters corresponding to neither fishery nor area.
#| label: tbl-weirdparameters

for (i in 1 : nrow(location_biz)){
  location_bizi <- location_biz$location[i]
  var_biz <- DBI::dbGetQuery(con_salmoglob, glue::glue_sql("SELECT distinct(var_mod) FROM public.database 
where location in ({location_bizi})", .con=con_salmoglob))
colnames(var_biz) <- location_bizi
print(kable(var_biz[,,drop=FALSE], row.names=FALSE))
}
```

``` {r db_comparaison}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE

database <- DBI::dbGetQuery(con_salmoglob, "SELECT * FROM public.database")
database_archive <- DBI::dbGetQuery(con_salmoglob, "SELECT * FROM public.database_archive")

# List of commun columns
cols <- c("version", "year", "type", "age", "area", "location", "metric", "var_mod")

# getting values that are not present in database anymore
for (col in cols) {
  diff_values <- setdiff(database_archive[[col]], database[[col]])
  if (length(diff_values) > 0) {
    cat("Values present in database_archive but not in database for", col, "column :\n")
    print(diff_values)
  }
}
```



``` {r check_parameter_location}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE


result <- database %>%
  group_by(var_mod) %>%
  summarise(location_count = n_distinct(location))
knitr::kable(result, caption = "Number of locations per var_mod") %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

So in the end, only omega has 25 locations, and in this case the location corresponds to area.
This means we can get rid of the location column. For omega we can keep it,; so we can add a column with a foreign key to area in the parameters table where priors will be stored.

# Sea age


Salmon mature at various sea ages, typically returning to freshwater to spawn after one to three years at sea, but also sometimes at older sea ages; this varies widely between populations. Those salmon that return after one year at sea are referred to as one-sea-winter (1SW) salmon, or grilse, with older fish categorised as 2SW, 3SW, etc. In practice, however, for management purposes these older sea age fish are typically aggregated and collectively referred to as multi-sea-winter (MSW) salmon. The sea age when salmon become sexually mature depends on genetics as well as growing conditions in the sea, and possibly freshwater, although the precise proximate factors initiating homeward migration are unknown (Hansen and Quinn, 1998). The sea age of Atlantic salmon is important in the context of stock definition since these different groups of fish have different migration routes, return at different times and are differentially exploited in fisheries. Thus, for example, it is only potential MSW salmon that are exploited in the distant water salmon fishery that operates off the west coast of Greenland [@ICES2021_wgnas_stock_annex].

``` {r check_age}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE


summary_age <- DBI::dbGetQuery(con_salmoglob, 
  'SELECT count(*) N, age FROM public.database group by age')%>% arrange(age)
knitr::kable(summary_age, caption = "Number age data categorized by age") %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

summary_age_parm <- DBI::dbGetQuery(con_salmoglob, 
  'SELECT count(*) N, age, var_mod FROM public.database group by age, var_mod order by age, var_mod') 
knitr::kable(summary_age_parm %>% filter(age=="_"), caption = "Number age data categorized by age, parameters without age, n is the number of lines in the db") %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
knitr::kable(summary_age_parm %>% filter(age!="_"), caption = "Number age data categorized by age, n is the number of lines in the db") %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

distinct_age_parm <- DBI::dbGetQuery(con_salmoglob, 
  "WITH t1 AS (
  SELECT age, 
  var_mod 
  FROM public.database 
  group by age, var_mod 
  order by age, var_mod ),
  t2 AS (
  SELECT age as age2, 
  var_mod as var_mod2
  FROM public.database 
  group by age, var_mod 
  order by age, var_mod)
  SELECT age, age2, var_mod from t1 JOIN t2 on t1.var_mod= t2.var_mod2 
  where age!=age2
  ")
knitr::kable(distinct_age_parm, caption = "Variables using more than 1 age (e.g. from which the age cannot be derived from the variable itself.)") %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

> [NOTE] Only eggs, p_smolt, p_smolt_pr, and prop_female need an age, the other is contained in the name of the variable.

> [NOTE] So the age also covers information on maturity but the only time it is really used outside from the metadata (eggs, smolt, prop_female) the maturity is not necessary.

> [QUESTION WGNAS] Why is omega not mixed ?

> [QUESTION WGNAS] Would it not make more sense to store 2SW as MSW  (multi-sea-winter) ? So in the referential have 1SW 2SW 3SW ... how many ? and then MSW ?

``` {r check_maturity_metadata}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE


summary_lifestage_metadata <- DBI::dbGetQuery(con_salmoglob, 
  'SELECT count(*) as  n,  life_stage FROM public.metadata group by life_stage')%>% arrange(life_stage)
knitr::kable(summary_lifestage_metadata,
 caption = "Number of lines with lifestage in the metadata table") %>%
 kable_material(c("striped", "hover"))
``` 

> [NOTE] get rid of `Adults` replace with `Adult`.

> [NOTE] get rid of `Multiple` there is only one instance.

> [NOTE] Now there is the PFA, which is fine, but not really a stage.

# Developmental stage

We first start by looking at the possible reference tables in ICES corresponding to both maturity and stage. Currently we have to store information about the sea age (`0SW, 1SW, 2SW, ...,MSW`) , the freshwater age (`1FW 2FW 3FW 4FW ...`).
The maturity could be stored in the metadata as it seems to be linked always with parameters. Currently in wgnas we have maturity : immature, mature, not maturing and post return. In the metadata we have `egg, smolts, spawner, adults`


``` {r icesVocabrivers}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE
types <- icesVocab::getCodeTypeList()
types[grep('stage', tolower(types$Description)),]%>% kable()
TS_MATURITY <- icesVocab::getCodeList('TS_MATURITY')
TS_DevStage <- icesVocab::getCodeList('TS_DevStage')
# Devstage is 1 to 15 => no use
DevScale <- icesVocab::getCodeList('DevScale')
# At the present the codetypes target Eggs and Larvae surveys
# This is a description of scales types using different publications => not for use()
kable(TS_MATURITY, caption = "TS_MATURITY") %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed")) 
kable(TS_DevStage, caption = "Devstage scale, this seems to be about shrimp (berried seems to an egg which looks at you with eyes in shrimps....)") %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed")) 
```

> [QUESTION ICES] Does it make sense to use a code outside from its scope (I seems to me that yes). If so can we use the TS_DevStage and add values in it and propose definitions ? 

There seem to be a correspondence between the 4 stage scale and the maturity

| Stage wgnas |  stage (4 scale ICES) | table |
| ------------| ------------------------------------------------------| ------------|
| eggs     |         Egg                   | TS_DevStage | 
| smolt    |                                |                |
| immature |  Immature (6-stage scale) |TS_MATURITY | 
| Non mature (metadata) |  Immature (6-stage scale) | TS_MATURITY |
| PFA      |                             | see question below |
| mature   |  Maturing (6-stage scale) ? | TS_MATURITY |
| mature   |  Pre-spawning (6-stage scale)  ?| TS_MATURITY |
| not maturing| Resting/Skip of spawning (4-stage scale, additional option)|TS_MATURITY |
| spawner (metadata table)	| Spawning (6-stage scale) |TS_MATURITY |
| post-return |  Post-spawning (5-stage scale) |TS_MATURITY |
: Life stages comparaison between WGNAS database and ICES vocabularies {#tbl-lifestagescomparaison}

> [QUESTION wgnas] Is the correspondence mature / maturing correct or is it pre -spawing? 

> [QUESTION wgnas] Is the correspondence OK. Do we really need PFA stage or could we just describe it in the metadata ?

> [QUESTION ICES] Could we add smolt and pfa (pre fisheries abundance) somewhere ?

# Metric

The metric are linked with coefficients, they don't need to be stored in the main db

``` {r check_metric}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE


summary_metric <- DBI::dbGetQuery(con_salmoglob, 
  'SELECT count(*) as  n,  metric FROM public.database group by metric')%>% arrange(metric)
knitr::kable(summary_metric,
 caption = "Number of lines with metric in the database table") %>%
 kable_material(c("striped", "hover"))

 summary_metric <- DBI::dbGetQuery(con_salmoglob, 
  'SELECT count(*) as  n,  metric FROM public.metadata group by metric')%>% arrange(metric)
knitr::kable(summary_metric,
 caption = "Number of lines with metric in the metadata table") %>%
 kable_material(c("striped", "hover"))

``` 

 There is a problem of correspondence between the database and metadata, detailed below :

``` {r check_metric_correspondence}
#| echo: TRUE
#| eval: TRUE
#| warning: FALSE
#| message: FALSE

# this query didn't return as expected
 pb <- DBI::dbGetQuery(con_salmoglob, 
  "SELECT database.var_mod, 
  metadata.metric as metric_metadata, 
  database.metric as metric_database  
  FROM public.metadata 
  JOIN public.database
  ON database.var_mod=metadata.var_mod
  WHERE metadata.metric != database.metric
  ")
knitr::kable(pb,
 caption = "Variables with correspondence pb for metric between the metadata and the database table") %>%
 kable_material(c("striped", "hover"))

 pb1 <- DBI::dbGetQuery(con_salmoglob, 
  "SELECT distinct metadata.var_mod, 
  metadata.metric as metric_metadata,
  database.metric as metric_database  
  FROM public.metadata  
  left JOIN public.database
  ON database.var_mod=metadata.var_mod
  WHERE metadata.metric in ('Precision','Estimate')
  ")
knitr::kable(pb1,
 caption = "Variables with correspondence pb for metric between the metadata and the database table") %>%
 kable_material(c("striped", "hover"))

``` 


# Hierarchical structure of the database

The database could start with the simplest structure, with a basic table corresponding to all data. 
Then three tables could be created, one per species. This is to allow querying the different tables independently. From these species tables, three different tables could be produced, one for data, one for parameters outputs, one for parameters priors.
The tables could have a different format, meaning maybe parameter does not have stage (only if this simplifies further development). Data should have stage because eel data need stage. The stage can be easily pulled up with a joining of the metadata table.


From these three table on could envisage the creation of specific table for working groups. Meaning one table for eel (wgeel), one table for salmon (wgnas), one table for salmon (wgbast), and one table for trutta (wgtrutta).

## referential tables

Similarly, referential tables could be created with a mother table from which specific (or wg specific) tables would inherit. This would make the setting up of consistent foreign key more easy. For instance wgbast could reference different age class than wgnas, and the stage would be completely different between wgeel and wgnas reference daughter tables. Some of these referential table would be common between species (e.g. source from ICES vocab, which corresponds to working group or accession events (datacalls)).

## unicity constraints

Another important point to add (at least to the salmoglob database) is unicity constraint. As some values would be null, creating unicity constraints with indexes would be necessary. These allow to have different levels of constraints for instance the unicity would be defined for :
(year, age, area, parameter)
(year, age, parameter)
(year, area, parameter)
(year, parameter)

One of the table will have to contain twice the area it will have to be treated separately.
(year, area, area,  parameter)


## Other comments.

Currently stage in metadata not consistent, replicates information about maturity but not always. The lack of consistency in the metadata is not a problem as this table refers to the model. 

Additional values about maturity, stage, can be stored in the metadata table.

There is a discrepancy between data in the historical dataset and the current, so we need to create additional parameters for the historical database and this will need to be checked.

``` {r conmigdb}
#| echo: FALSE
#| eval: FALSE

con_diaspara = dbConnect(Postgres(), dbname=cred$dbnamediaspara,host=cred$host,port=cred$port,user=cred$userdiaspara, password=cred$passworddiaspara)
```

# Referentials


```{sql create_referentials}
--| echo: TRUE
--| eval: FALSE

-- CREATE REFERENTIAL TABLES

/*
This is a comment
*/
DROP schema if exists "ref";
CREATE schema "ref";
GRANT ALL PRIVILEGES ON SCHEMA "ref" TO diaspara_admin ;
GRANT ALL PRIVILEGES ON SCHEMA public TO diaspara_read ;
GRANT CONNECT ON DATABASE "diaspara" TO diaspara_read;
ALTER DATABASE "diaspara" OWNER TO diaspara_admin;

-- edit pg_hba.conf on the server


-- TODO search countries for Salmon US
CREATE TABLE ref.tr_country_cou (
    cou_code character varying(2) NOT NULL,
    cou_country text NOT NULL,
    cou_order integer NOT NULL,
    geom public.geometry,
    cou_iso3code character varying(3)
);
-- how to inegrate with hierarchical level in salmodb ? Same for eel ?

ALTER TABLE ref.tr_country_cou OWNER TO postgres;
GRANT ALL ON SCHEMA ref diaspara_admin;
CREATE ROLE diaspara_read

CREATE TABLE "ref".tr_pararmeter_parm (
  parm_id serial4 NOT NULL,
  parm_name TEXT NOT NULL UNIQUE,
  parm_species TEXT
  parm_description text NULL,
  parm_uni_code varchar(20) NULL,
  CONSTRAINT parm_pkey PRIMARY KEY (typ_id),
  CONSTRAINT c_fk_parm_uni_code FOREIGN KEY (typ_uni_code) REFERENCES "ref".tr_units_uni(uni_code) ON UPDATE CASCADE
);


``` 